[{"path":"https://optad.github.io/adoptr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 adoptr authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr.html","id":"two-stage-designs-for-clinical-trials","dir":"Articles","previous_headings":"","what":"Two-stage designs for clinical trials","title":"Get started with adoptr","text":"prospectively planned confirmatory clinical trials long-standing debate merits allowing pre-planned interim analyses stop modify ongoing trial, cf.¬† Bauer et al., 2016. common consensus two-stage designs still maintain strict control maximal type one error rate despite data dependent decision interim analysis. authors use combination function approaches combine either independent p values test statistics respective stages. pre-specified weights maintains type one error rate control. adoptr provide tools explore optimal two-stage designs one two-arm clinical trials (asymptotically) normally distributed stage-wise independent test statistics. Pilz et al., 2019, argued techniques necessary, fact, counter-productive, since pre-specified weights might sub-optimal. Instead, one may see problem defining optimal two-stage designs variational problem find optimal configuration ùíü:=(n1,c1e,c1f,n2(‚ãÖ),c2(‚ãÖ)) \\mathcal{D}:=\\big(n_1, c_1^e, c_1^f, n_2(\\cdot), c_2(\\cdot)\\big)  directly given objective function potentially set constraints. relaxation mixed-integer problem real numbers can solved standard methods analysis. E.g., one construct implicit solution solving corresponding Euler-Lagrange equation given first-stage find optimal first-stage configuration, cf.¬†Pilz et al., 2019. Instead, adoptr package implements direct numerical solution algorithm embedding variation problem via set pivot points ‚Ñùk\\mathbb{R}^k solving corresponding finite-dimensional problem using gradient-free numerical optimization procedures (COBYLA / nloptr).","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Get started with adoptr","text":"Consider two-arm case comparing two group means mean. Let Œ¥\\delta difference means assume aim reject null hypothesis ‚Ñã0:Œ¥‚â§0\\mathcal{H}_0: \\delta \\leq 0. assume power 80% Œ¥=0.4\\delta=0.4 type-one-error rate 2.5% boundary null hypothesis Œ¥‚â§0.0\\delta\\leq0.0 required. situation, one-sided t-test require sample size 5151 individuals per-group. willing accept fact sample size two-stage design inherently unknown planning stage, reduce expected sample size alternative optimizing two-stage design respect quantity. Since two-stage design, definition, degrees freedom single-stage design, must least good terms expected sample size single-stage design - expected sample size always 51.","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr.html","id":"define-hypotheses-and-data-generating-mechanism","dir":"Articles","previous_headings":"Example","what":"Define hypotheses and data-generating mechanism","title":"Get started with adoptr","text":"First, define null alternative hypotheses prior distributions unknown parameter Œ¥\\delta. Next, define data-generating mechanism (data distribution). Currently, normally distributed test statistics known variance, normal approximation binary endpoints supported. example, choose normal distribution, .e., assume continuous outcome. example binomial data distribution, cf.¬†vignette composite scores.","code":"library(adoptr) H_0 <- PointMassPrior(.0, 1) H_1 <- PointMassPrior(.4, 1) datadist <- Normal(two_armed = FALSE)"},{"path":"https://optad.github.io/adoptr/articles/adoptr.html","id":"specify-optimization-problem","dir":"Articles","previous_headings":"Example","what":"Specify optimization problem","title":"Get started with adoptr","text":"begin defining expected sample size alternative hypothesis: Similarly, can define power type-one-error rate integrating conditional power respect alternative null hypothesis respectively: complete problem specification, need provide initial design integration order Gaussian quadrature rule used numerical integration variational objective c1fc_1^f c1ec_1^e. adoptr provides heuristic method obtain initial design. based one-stage design specific constraints type one error rate power. However, may efficient use situation-specific initial design. decision boundaries heuristically picked concordance single-stage design. can check whether initial design fulfills constraints operating characteristics: can now proceed defining solving optimization problem: , default setting optimizer box constraints seem worked . numerical procedure converged iterations. can plot resulting optimized design may plotted together conditional power.  Numerical integration yields expected sample size way single-stage 51. can check results simulated values values simulation numerical integration almost identical constraints also met almost perfectly:","code":"ess <- ExpectedSampleSize(datadist, H_1) power <- Power(datadist, H_1) toer  <- Power(datadist, H_0) initial_design <- get_initial_design(   theta = .4,   alpha = .025,   beta  = .2,   type_design  = \"two-stage\",   dist  = datadist,   order = 7L ) evaluate(power, initial_design) #> [1] 0.797953 evaluate(toer, initial_design) #> [1] 0.02499995 opt_res <- minimize(      ess,      subject_to(     power >= 0.8,     toer  <= .025   ),      initial_design ) opt_res$nloptr_return$iterations plot(   opt_res$design,    \"Conditional power\" = ConditionalPower(datadist, H_1) ) evaluate(ess, opt_res$design) #> [1] 39.85593 df_sim <- simulate(   opt_res$design,    nsim = 10^6,    dist = datadist,    theta = .4,    seed = 42 )  n <- df_sim$n1 + df_sim$n2 mean(n) #> [1] 39.84 sd(n) / sqrt(length(n)) #> [1] 0.01372648 evaluate(toer, opt_res$design) #> [1] 0.02500571 evaluate(power, opt_res$design) #> [1] 0.7985303"},{"path":"https://optad.github.io/adoptr/articles/adoptr.html","id":"variations","dir":"Articles","previous_headings":"Example","what":"Variations","title":"Get started with adoptr","text":"purpose adoptr provide high-level interface exploring comparing different designs experiment different combinations objective functions constraints. particular, adoptr supports: Important predefined scores (conditional) power sample size functions well framework constraints scores (cf.¬†conditional scores). Arbitrary continuous discrete prior distributions single location parameter Œ∏\\theta test statistic. Support simple arithmetic operations scores quickly define weighted sums etc. (cf.¬†composite scores). Relatively flexible framework defining new scores.","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"Confirmatory clinical trials conducted strictly regulated environment. key quality criterion put forward relevant agencies (US Food Drug Administration et al. (2019), Committee Medicinal Products Human Use others (2007)) study supposed provide evidence regulatory acceptance new drug treatment strict type one error rate control. requirement often seen conflicting perceived need make trials flexible , e.g., early stopping futility, group-sequential enrollment, even adaptive sample size recalculation. excellent historical review development field adaptive clinical trial designs struggles along way given Bauer et al. (2015). manuscript, focus lies exclusively adaptive two-stage designs one unblinded interim analysis. early stopping futility efficacy allowed final sample size well critical value reject null hypothesis chosen data-driven way. plethora methods modifying design ongoing trial based interim results without compromising type one error rate control (Bauer et al. 2015) criteria deciding adaptation performed interim analysis perform interim analysis still widely based heuristics. Bauer et al. mention issue guiding adaptive decisions interim principled (.e., ‚Äòoptimal‚Äô) way stating ‚Äò[t]question might arise potential decisions made interim stages might better placed upfront planning stage.‚Äô Following Mehta Pocock (2011), Jennison Turnbull (2015) developed principle approach optimal interim sample size modifications, .e., conduct interim decision (conditional interim results) optimizes unconditional performance score. approach, however, still restricted unnecessarily. Recently, Pilz et al. (2019) extended work fully general variational problem optimization problem given performance score (optionally constraints) solved sample size adaptation function critical value function time point interim decision simultaneously. approach application ideas put forward single-arm trials binary endpoint several years (Englert Kieser (2013), Kunzmann Kieser (2016), Kunzmann Kieser (2020)) setting continuous test statistics. Clearly, relaxing problem continuous sample sizes test statistics, theory becomes much tractable, important connections conditional unconditional optimality can discussed much easier (Pilz et al. 2019). key insight recent development fact true challenge designing adaptive trial less technical methodology controlling type one error rate rather choice optimality criterion. issue much less pressing single-stage designs since sensible criteria equivalent minimizing overall sample size. Thus, case, ‚Äòdesign‚Äô often completely specified given power type one error rate constraints. complex adaptive designs, however, much sensible criteria (minimize maximal sample size, expected sample size, expected costs, etc.) balance conditional unconditional properties must explicitly specified (cf.¬†Section 6). added complexity might seen daunting practitioners, also chance tailoring adaptive designs specifically particular situation. R-package (R Core Team 2019) adoptr aims providing simple yet customizable interface specifying broad class objective functions constraints single- two-arm, one- two-stage designs approximately normally distributed endpoints. goal adoptr enable relatively easy experimentation different notions optimality shift focus optimize optimize. following, first give definition problem setting addressed adoptr technicalities translating underlying variational problem simple multivariate optimization problem motivating need R-package. present core functionality adoptr addressing issue facilitating validation open-source software regulated environment discussing potential future work adoptr.","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:setting","dir":"Articles","previous_headings":"","what":"Setting","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"consider problem two-stage, two-arm design establish superiority treatment placebo respect mean difference. Assume end data Yjg,iY_j^{g, } observed jj-th individual trial stage ‚àà{1,2}\\\\{1,2\\} treatment (g=Tg=T) placebo (g=Cg=C). Let nin_i per-group sample size stage ii consider stage-wise test statistics Xi:=‚àëj=1niYjT,‚àí‚àëj=1niYjC,iœÉ2ni   X_i := \\frac{\\sum_{j=1}^{n_i}Y_j^{T,} - \\sum_{j=1}^{n_i}Y_j^{C,}}{\\sigma\\,\\sqrt{2\\,n_i}}  =1,2i=1,2. assumption Yjg,‚àºiidFgY_j^{g, }\\stackrel{iid}{\\sim} F_g ùêÑ[FT]‚àíùêÑ[FC]=Œ∏\\boldsymbol{E}[F_T] - \\boldsymbol{E}[F_C] = \\theta common variance œÉ2\\sigma^2, central limit theorem, asymptotic distribution X1X_1 ùí©(n1/2Œ∏,1)\\mathcal{N}(\\sqrt{n_1/2}\\, \\theta, 1). Formally, null hypothesis superiority test thus ‚Ñã0:Œ∏‚â§0\\mathcal{H}_0:\\theta\\leq 0. Based interim outcome X1X_1, decision can made whether either stop trial early futility X1<c1fX_1<c_1^f, stop trial early efficacy (early rejection null hypothesis) X1>c1eX_1>c_1^e, enter stage two X1‚àà[c1f,c1e]X_1\\[c_1^f, c_1^e]. Conditional proceeding second stage, holds X2|X1‚àà[c1f,c1e]‚àºùí©(n2/2Œ∏,1)X_2\\,|\\,X_1\\[c_1^f, c_1^e]\\sim\\mathcal{N}(\\sqrt{n_2/2}\\, \\theta, 1). second stage, null hypothesis rejected X2>c2(X1)X_2 > c_2(X_1) stage-two critical value c2:x1‚Ü¶c2(x1)c_2:x_1\\mapsto c_2(x_1). test ‚Ñã0\\mathcal{H}_0 significance level Œ±\\alpha, stage-one critical values c1fc_1^f c1ec_1^e well c2(‚ãÖ)c_2(\\cdot) must chosen way protects overall maximal type one error rate Œ±\\alpha. Note convenient define c2(x1)=‚àûc_2(x_1) = \\infty x1<c1fx_1<c_1^f c2(x1)=‚àí‚àûc_2(x_1) = -\\infty x1>c1ex_1>c_1^e since power curve design given Œ∏‚Ü¶ùêèùê´Œ∏[X2>c2(X1)]\\theta\\mapsto\\boldsymbol{Pr}_\\theta\\big[X_2>c_2(X_1)\\big]. results classical group-sequential design several methods proposed literature choosing early-stopping boundaries c1fc_1^f c1ec_1^e (O‚ÄôBrien Fleming (1979), Pocock (1977)) defining stage-two rejection boundary function c2(‚ãÖ)c_2(\\cdot) (Bauer K√∂hne (1994), Hedges Olkin (1985)). Often, inverse-normal combination test (Lehmacher Wassmer 1999) applied c2(‚ãÖ)c_2(\\cdot) defined linear function stage-one test-statistic c2(x1)=c‚àíw1x1w2‚Äö    c_2(x_1) = \\frac{c - w_1 x_1}{w_2}‚Äö  critical value cc predefined weights w1w_1 w2w_2. commonly, stage-wise test statistics weighted terms respective sample sizes, .e., w1=n1/(n1+n2)w_1 = \\sqrt{n_1 / (n_1+n_2)} w2=n2/(n1+n2)w_2 = \\sqrt{n_2 / (n_1+n_2)}. choice weights optimal sense minimizes variance final test statistic assumed sample sizes indeed realized (Zaykin 2011). Note, however, prespecified weights become inefficient sample size deviates strongly anticipated value (cf. Wassmer Brannath (2016), chapter 6.2.5). natural extension group-sequential framework allow second stage sample size also depend observed interim outcome, .e., consider function n2:x1‚Ü¶n2(x1)n_2:x_1\\mapsto n_2(x_1) instead fixed value n2n_2. ‚Äòadaptive‚Äô two-stage designs thus completely characterized five-tuple ùíü:=(n1,c1f,c1e,n2(‚ãÖ),c2(‚ãÖ))\\mathcal{D}:=\\big(n_1, c_1^f, c_1^e, n_2(\\cdot), c_2(\\cdot)\\big). required sample size critical value single-stage design uniquely defined given type one error rate power constraints, much less clear design parameters two-stage design selected. especially true since n2n_2 c2c_2 functions thus parameter space fact infinite-dimensional. order compare different choices design parameters, appropriate scoring criteria essential. widely applied criterion expected sample size alternative hypothesis (see, e.g., Jennison Turnbull (2015)). However, variety scoring criteria incorporated even combined order rate two-stage design. instance, conditional power defined probability reject null hypothesis alternative given interim result X1=x1X_1=x_1: CPŒ∏(x1):=ùêèùê´Œ∏[X2>c2(X1)|X1=x1]. \\operatorname{CP}_\\theta(x_1) := \\boldsymbol{Pr}_\\theta \\big[X_2 > c_2(X_1) \\, \\big| \\, X_1=x_1\\big].  Hence, conditional power conditional score given power conditioned first-stage outcome X1=x1X_1=x_1. Vice versa, power can seen unconditional score obtained integrating conditional power possible stage-one outcomes, .e., PowerŒ∏=ùêÑŒ∏[CP(X1)]. \\operatorname{Power_\\theta} = \\boldsymbol{E}_\\theta\\big[\\operatorname{CP}(X_1)\\big].  Intuitively, makes sense require minimal conditional power upon continuation second stage since one might otherwise continue trial little prospect still rejecting null hypothesis. demonstrate consequences heuristic Section 6.4. scoring criterion selected, design parameters may chosen order optimize objective. first ones address problem Jennison Turnbull (2015) minimized expected sample size ESSŒ∏(ùíü):=ùêÑŒ∏[n(X1)]:=ùêÑŒ∏[n1+n2(X1)] \\text{ESS}_{\\theta}(\\mathcal{D}) := \\boldsymbol{E}_{\\theta} \\big[n(X_1) \\big] := \\boldsymbol{E}_{\\theta} \\big[n_1 + n_2(X_1) \\big]  two-stage design given n1,c1f,c1en_1,c_1^f, c_1^e respect n2(‚ãÖ)n_2(\\cdot) given power type one error rate constraints. function c2(‚ãÖ)c_2(\\cdot), however, optimized. Instead, Jennison Turnbull (2015) used inverse-normal combination test approach derive c2c_2 given n2(‚ãÖ)n_2(\\cdot) n1n_1. Pilz et al. (2019), authors demonstrated restriction necessary variational problem deriving functions n2(‚ãÖ)n_2(\\cdot) c2(‚ãÖ)c_2(\\cdot) given n1,c1f,c1en_1,c_1^f, c_1^e minimize expected sample size can solved analyzing corresponding Euler-Lagrange equation. Nesting step standard optimization stage-one parameters allows identifying optimal set design parameters without imposing parametric assumptions c2(‚ãÖ)c_2(\\cdot). result, fully optimal design ùíü*:=(n1*,c1f,*,c1e,*,n2*(‚ãÖ),c2*(‚ãÖ))\\mathcal{D}^*:=\\big(n_1^*, c_1^{f,*}, c_1^{e, *}, n_2^*(\\cdot), c_2^*(\\cdot)\\big) following general optimization problem derived minimizeESSŒ∏1(ùíü)subject :ùêèùê´Œ∏0[X2>c2(X1)]‚â§Œ±,ùêèùê´Œ∏1[X2>c2(X1)]‚â•1‚àíŒ≤\\begin{align} & \\text{minimize} && \\operatorname{ESS}_{\\theta_1}(\\mathcal{D}) &&&& \\\\ & \\text{subject :} && \\boldsymbol{Pr}_{\\theta_0}\\big[X_2>c_2(X_1)\\big] &&\\leq \\alpha, &&&& \\\\ &&& \\boldsymbol{Pr}_{\\theta_1}\\big[X_2>c_2(X_1)\\big] &&\\geq 1-\\beta &&&& \\end{align} Œ∏0=0\\theta_0=0.","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"direct-variational-perspective","dir":"Articles","previous_headings":"","what":"Direct variational perspective","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"adoptr, simpler solution strategy solving Euler-Lagrange equation locally applied problem class. propose embed entire problem finite-dimensional parameter space solve corresponding problem stage-one stage-two design parameters simultaneously using standard numerical libraries. .e., adopt direct approach solving variational problem. done defining discrete set pivot points xÃÉ1()‚àà(c1f,c1e),=1,‚Ä¶,k\\widetilde{x}_1^{()}\\(c_1^f, c_1^e), =1,\\ldots,k, interpolating c2c_2 n2n_2 pivots. use cubic Hermite splines (Fritsch Carlson 1980) sufficiently flexible, even moderate number pivots, approximate realistic stage-two sample size critical value functions. Since optimal functions generally smooth (Pilz et al. 2019) well suited spline interpolation. Within adoptr validation report (cf.¬†Section 7) investigate empirically shape approximated functions increasing number pivots value 5 7 improve optimization results. latter implies relatively small number pivot points appears sufficient obtain valid spline approximations optimal functions. Note pivots needed continuation region since functions (piecewise) constant within early stopping regions. adoptr, pivots defined nodes Gaussian quadrature rule degree kk. choice allows fast precise numerical integration conditional score continuation region, e.g., ESSŒ∏(ùíü)=‚à´n(x1)fŒ∏(x1)dx1‚âàn1+‚àë=1kœâin2(xÃÉ1())fŒ∏(xÃÉ1()),\\begin{align}  \\text{ESS}_{\\theta}(\\mathcal{D})  = \\int n(x_1) f_{\\theta} (x_1) \\operatorname{d} x_1 \\approx n_1 + \\sum_{=1}^{k} \\omega_i\\, n_2\\big(\\widetilde{x}_1^{()}\\big) f_{\\theta} \\big(\\widetilde{x}_1^{()}\\big), \\end{align} fŒ∏f_\\theta probability density function X1|Œ∏X_1\\,|\\,\\theta œâi\\omega_i corresponding weights integration rule. weights depend kk nodes just need scaled integration interval. Consequentially, objective function smooth optimization parameters resulting optimization problem dimension 2k+32k+3, tuning parameters (n1,c1f,c1e,n2(xÃÉ1(1)),‚Ä¶,n2(xÃÉ1(k)),c2(xÃÉ1(1)),‚Ä¶,c2(xÃÉ1(k)))\\big(n_1, c_1^f, c_1^e, n_2\\big(\\widetilde{x}_1^{(1)}\\big), \\dots, n_2\\big(\\widetilde{x}_1^{(k)}\\big), c_2\\big(\\widetilde{x}_1^{(1)}\\big), \\dots, c_2\\big(\\widetilde{x}_1^{(k)}\\big)\\big). Standard numerical solvers may employed minimize . Since adoptr enables generic objectives (cf.¬†Section 6.3), uses gradient-free optimizer COBYLA (Powell 1994) internally via R-package nloptr (Johnson (2018), Ypma, Borchers, Eddelbuettel (2018)). commonly used unconditional performance scores S(ùíü)S(\\mathcal{D}) can seen expected values conditional scores S(ùíü|X1)S(\\mathcal{D}|X_1) S(ùíü)=ùêÑ[S(ùíü|X1)]S(\\mathcal{D}) = \\boldsymbol{E}\\big[S(\\mathcal{D}|X_1)\\big] similar way power expected sample size. ‚Äòintegral score‚Äô can computed quickly reliably adoptr via choice pivots outlined . correctness numerically integrated scores checked adoptr validation report comparing numerical integrals simulated results. Note tacitly relaxed sample sizes real numbers argument fact restricted positive integers. Integer-valued n1n_1 n2n_2 , however, lead NP-hard mixed-integer problem. experiments, found merely rounding n1n_1 n2n_2 optimization works fine. extensive validation suite (cf.¬†Section 7) evaluates numerical integration simulation whether included constraints fulfilled optimal designs rounded sample sizes. now, neither constraints violated efficiency loss respect underlying objective function observed. theory, one re-adjust decision boundaries rounded sample sizes, failed see practical benefit , even small trials rounding error largest (data shown).","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"the-need-for-an-r-package","dir":"Articles","previous_headings":"","what":"The need for an R package","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"Bauer et al. (2015) state adequate statistical software adaptive designs ‚Äòincreasingly needed evaluate adaptations find reasonable strategies‚Äô. Commercial software JMP (SAS Institute Inc., n.d.) Minitab (Minitab, Inc. 2020) allow planning analyzing wide range experimental setups. Amongst others, provide tools randomization, stratification, block-building, D-optimal designs. general purpose statistical software packages , however, allow planning specialized multi-stage designs encountered clinical trials. group-sequential designs, planning capabilities available SAS procedure seqdesign (SAS Institute Inc., n.d.b), PASS (NCSS 2019), ADDPLAN (ICON plc 2020). East (Cytel 2020) also supports design, simulation analysis experiments interim analyses. East ADAPT East SURVADAPT modules support sample size recalculation. Furthermore, various open-source R-packages analysis multi-stage designs. package adaptTest (Vandemeulebroecke 2009) implements combination tests adaptive two-stage designs. AGSDest (Hack, Brannath, Brueckner 2019) allows estimation computation confidence intervals adaptive group-sequential designs. detailed overviews software adaptive clinical trial designs can found Bauer et al. (2015), chapter 6, Tymofyeyev (2014). choice software optimally designing two- multi-stage designs, however, much limited. Current R-packages concerned optimal clinical trial designs OptGS (Wason Burkardt (2015), Wason (2015)) rpact (Wassmer Pahlke 2019). , however, exclusively focused group-sequential designs lack ability specify custom objective functions constraints. lack flexibility formulating objective function constraints might lead --shelf solutions entirely reflecting needs particular trial consequentially resulting inefficient designs. R-package adoptr aims providing simple interactive yet flexible interface addressing range optimization problems encountered two-stage one- two-arm clinical trials. particular, adoptr allows model priori uncertainty Œ∏\\theta via prior distributions thus supports optimization uncertainty (cf.¬†Section 6.2). adoptr also supports combination conditional (X1X_1) unconditional scores constraints address concerns type-one-error-rate control (unconditional score) , e.g., minimal conditional power (conditional score) simultaneously (cf.¬†Section 6.3). facilitate adoption advanced trial designs clinical trials community, adoptr also features extensive test validation suite (cf.¬†Section 7). following, outline key design principles adoptr. Interactivity: major advantage R-programming language powerful metaprogramming capabilities flexible class system. combination non-standard evaluation S4 classes, hope achieve structured modular way expressing optimization problems clinical trials integrates nicely interactive workflow. feel step-wise problem formulation via creation modular intermediate objects, can explored modified separately, encourages exploration different options. Reliability: crux open-source software development clinical trials achieving demonstrable validation. Potential users need convinced software quality need able comply respective validation requirements often require ability produce validation report. burden typically results innovative software used - simply validation effort stemmed. address issue extensive unit test suite companion validation report (cf.¬†Section 7). Extensibility: want impose particular choice scores constraints promote particular notion optimality clinical trial designs. cases composition existing scores sufficient, object-oriented approach adoptr facilitates definition custom scores constraints seamlessly integrate remainder package.","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:structure","dir":"Articles","previous_headings":"","what":"Adoptr‚Äôs structure","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"package adoptr based R‚Äôs S4 class system. allows use multiple dispatch classes multiple arguments method. section, central components adoptr described briefly. following figure gives structural overview main classes adoptr. compute optimal designs, object class UnconditionalScore must defined objective criterion. adoptr distinguishes ConditionalScores UnconditionalScores (cf.¬†Section 2). Scores can evaluated using method evaluate. unconditional scores, method requires Score object TwoStageDesign object, conditional scores (like conditional power), also requires interim outcome x1x_1. Note ConditionalScore S(ùíü|X1=x1)S(\\mathcal{D}|X_1=x_1) can converted UnconditionalScore S(ùíü)=ùêÑ[S(ùíü|X1)]S(\\mathcal{D}) = \\boldsymbol{E}\\big[S(\\mathcal{D}|X_1)\\big] using method expected. two widely used conditional scores pre-implemented ConditionalPower ConditionalSampleSize. unconditional counterparts Power ExpectedSampleSize. predefined unconditional scores MaximumSampleSize, evaluating maximum sample size, N1, measuring first-stage sample size, AverageN2, evaluating average stage-two sample size (improper prior). scores may used regularization variable stage-two sample sizes high stage-one sample size penalized. Users free define Scores (cf.¬†vignette ‚ÄòDefining New Scores‚Äô (Kunzmann Pilz 2020)). Moreover, different Scores can composed single one function composite (cf.¬†Section 6.3). conditional unconditional scores can also used define constraints - common case constraints power maximal type one error rate. function minimize takes unconditional score objective set constraints optimizes design parameters. adoptr, different kinds designs implemented. frequently applied case TwoStageDesign, .e., design one interim analysis sample size function varies interim test statistic. Another option subclass GroupSequentialDesign restricts sample size function continuation region single number, .e., n2(x1)=n2‚àÄx1‚àà[c1f,c1e]{n_2(x_1) = n_2\\ \\forall x_1\\[\\,c_1^f, c_1^e\\,]}. Additionally, adoptr supports computation optimal OneStageDesigns, .e., designs without interim analysis. Technically, one-stage designs implemented subclasses TwoStageDesign since can viewed limiting case n2‚â°0n_2\\equiv0 c1f=c1ec_1^f=c_1^e. Hence, methods implemented TwoStageDesigns also work GroupSequentialDesigns OneStageDesigns. Users can chose keep elements design fixed optimization using methods make_fixed (cf.¬†Section 6.5). joint data distribution adoptr consists two elements. distribution test statistic specified object class DataDistribution. Currently, three options Normal, Binomial, Student implemented. logical variable two_armed allows differentiation one- two-armed trials. Furthermore, adoptr supports prior distributions effect size. can PointMassPriors (cf.¬†Section 6.1) well ContinuousPriors (cf.¬†Section 6.2). following section, hands examples demonstrate capabilities adoptr syntax.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:standard_case","dir":"Articles","previous_headings":"Examples","what":"Standard case","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"Consider case randomized controlled clinical trial efficacy demonstrated terms superiority treatment placebo respect population mean difference Œ∏\\theta outcome. Let null hypothesis ‚Ñã0:Œ∏‚â§0\\mathcal{H}_0:\\theta\\leq 0. Assume maximal type one error rate controlled one-sided level Œ±=2.5%\\alpha=2.5\\% minimal power 90%90\\% point alternative Œ∏1=0.3\\theta_1=0.3 deemed necessary. simplicity‚Äôs sake, assume œÉ2=1\\sigma^2=1 without loss generality. required sample size one-stage design analysis one-sided two-sample tt-test roughly 235 per group. Using adoptr, two-stage design minimizing expected sample size alternative hypothesis can derived situation. First, data distribution specified normal. two_armed parameter allows switch single-armed two-armed trials. example, use simple point priors null alternative hypotheses. hypotheses corresponding scores (power values) can specified : Power score requires data distribution prior specified. example, choose PointMassPriors entire probability mass 11 single point, null hypothesis Œ∏=0\\theta = 0 compute type one error rate, alternative hypothesis Œ∏=0.3\\theta = 0.3 compute power. objective function expected sample size alternative. Since adoptr internally relies COBYLA implementation nloptr, initial design required. heuristic initial choice provided function get_initial_design. based fixed design fulfills constraints type one error rate power. type design (two-stage, group-sequential, one-stage) data distribution defined. Gaussian quadrature used optimization, one also specify order integration rule, .e., number pivot points early stopping futility early stopping efficacy. practice, order 7 turned sufficiently flexible obtain valid results (data shown). easy check initial design fulfill constraints (minimal power 90% maximal type one error rate 2.5%) equality evaluating respective scores: Alternatively, one might also evaluate constraint object directly via constraint objects normalized form h(ùíü)‚â§0h(\\mathcal{D}) \\leq 0 (unconditional) h(ùíü,x1)‚â§0h(\\mathcal{D}, x_1) \\leq 0 (conditional X1=x1X_1=x_1). Calling evaluate constraint object simply returns left-hand side inequality. actual optimization started invoking minimize modular structure problem specification intended facilitate inspection modification individual components. call minimize() designed close possible mathematical formulation optimization problem returns optimized design (opt1$design) well full nloptr return value details optimization procedure (opt1$nloptr_return). summary method objects class TwoStageDesign available quickly evaluate set ConditionalScores conditional power well UnconditionalScores power expected sample size. adoptr also implements default plot method overall sample size stage-two critical value functions first-stage test statistic x1x_1. plot method also accepts additional ConditionalScores conditional power. Calling plot method produces several plots interim test statistic x1x_1 xx-axis respective function yy-axis. Note slightly bent shape c2(‚ãÖ)c_2(\\cdot) function. two-stage designs based inverse-normal combination function, c2(‚ãÖ)c_2(\\cdot) linear definition. Since optimal shape c2(‚ãÖ)c_2(\\cdot) linear (almost), inverse-normal combination methods slightly less efficient (cf. Pilz et al. (2019) detailed discussion issue).","code":"R> datadist <- Normal(two_armed = TRUE) R> null        <- PointMassPrior(theta = .0, mass = 1.0) R> alternative <- PointMassPrior(theta = .3, mass = 1.0) R> power       <- Power(dist = datadist, prior = alternative) R> toer        <- Power(dist = datadist, prior = null) R> mss         <- MaximumSampleSize() R> ess <- ExpectedSampleSize(dist = datadist, prior = alternative) R> initial_design <- get_initial_design(theta = 0.3, alpha = 0.025, +                                       beta = 0.1, type = \"two-stage\", +                                       dist = datadist, order = 7) R> evaluate(toer, initial_design) R> evaluate(power, initial_design) R> evaluate(toer  <= .025, initial_design) R> evaluate(power >= .9, initial_design) R> opt1 <- minimize(ess, subject_to(power >= 0.9, toer  <= 0.025), +                   initial_design) R> cp <- ConditionalPower(dist = datadist, prior = alternative) R> summary(opt1$design, \"Power\" = power, \"ESS\" = ess, \"CP\" = cp) R> plot(opt1$design, `Conditional power` = cp)"},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:uncertainty","dir":"Articles","previous_headings":"Examples","what":"Optimization under uncertainty","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"adoptr limited point priors also supports arbitrary continuous prior distributions. Consider situation now assume prior effect size given much realistic truncated normal distribution mean 0.30.3 standard deviation 0.10.1, .e., Œ∏‚àºùí©[‚àí1,1](0.3,0.12)\\theta\\sim\\mathcal{N}_{[-1, 1]}(0.3, 0.1^2). order integration set 25 obtain precise results. objective function expected sample size prior replace power expected power ùêÑ[ùêèùê´Œ∏[X2>c2(X1)]|Œ∏‚â•0.1] \\boldsymbol{E} \\Big[ \\boldsymbol{Pr}_\\theta\\big[X_2>c_2(X_1)\\big] \\, \\Big| \\, \\theta \\geq 0.1 \\Big]  expected power given relevant effect (define minimal relevant effect 0.10.1). score can defined adoptr first conditioning prior. optimal design point prior achieves expected power optimal design truncated normal prior fulfilling expected power constraint given Note increased complexity problem requires larger maximal number iterations underlying optimization procedure. adoptr exposes nloptr options via argument opts. cases maximal number iterations exhausted, warning thrown. expected sample size prior obtained optimal design equals . shows increased uncertainty Œ∏\\theta requires larger sample sizes fulfill expected power constraint since expected sample size continuous prior considered section optimal design derived point alternative (see Section 6.1) .","code":"R> prior <- ContinuousPrior( +    pdf     = function(theta) dnorm(theta, mean = .3, sd = .1), +    support = c(-1, 1), +    order   = 25) R> ess <- ExpectedSampleSize(dist = datadist, prior = prior) R> epower <- Power(dist = datadist, prior = condition(prior, c(.1, 1))) R> evaluate(epower, opt1$design) R> opt2 <- minimize(ess, subject_to(epower >= 0.9, toer <= 0.025), +                   initial_design, +                   opts = list(algorithm = \"NLOPT_LN_COBYLA\", +                               xtol_rel = 1e-5, maxeval = 20000))"},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:utility_maximization","dir":"Articles","previous_headings":"Examples","what":"Utility maximization and composite scores","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"adoptr also supports composite scores. can used derive utility maximizing designs defining objective function combining expected power expected sample size instead imposing hard constraint expected power. example, situation one interested utility-maximizing design. , consider utility function u(ùíü):=200000ùêÑ[ùêèùê´Œ∏[X2>c2(X1)]|Œ∏‚â•0.1]‚àíùêÑ[n(X1)2], u(\\mathcal{D}) := 200000\\, \\boldsymbol{E} \\Big[ \\boldsymbol{Pr}_\\theta\\big[X_2>c_2(X_1)\\big] \\, \\Big| \\, \\theta \\geq 0.1 \\Big] - \\boldsymbol{E}\\Big[n(X_1)^2\\Big],  thus allowing direct trade-power sample size. , expected sample size chosen practitioner might prefer flatter sample size curves. can achieved expected squared sample size penalizing large sample sizes stronger low sample sizes. Furthermore, longer strict expected power constraint expected power becomes part utility function allows direct trade-two quantities. can interpreted pricing mechanism (cf. Kunzmann Kieser (2020)): Every additional percent point expected power (positive) value $2‚Ä≤000\\$ 2'000 increase ùêÑ[n(X1)2]\\boldsymbol{E}\\big[n(X_1)^2\\big] 11 incurs costs $1\\$ 1. goal compute design maximizing overall utility defined utility function u(ùíü)u(\\mathcal{D}) (equivalently minimize costs). composite score can defined via valid numerical R expression score objects. start defining score expected quadratic sample size minimizing corresponding negative utility without hard expected power constraint. expected power design three optimal designs computed far depicted joint plot. design using continuous prior requires higher sample sizes due higher uncertainty Œ∏\\theta. utility maximization approach results similar shapes n(‚ãÖ)n(\\cdot) c2(‚ãÖ)c_2(\\cdot) constraint optimization. However, sample sizes lower due design‚Äôs lower power possible allowing trade-expected power expected sample size. particular, maximal sample size utility-based design equals distinctly smaller case hard power constraint point prior (maximal sample size: ) continuous prior (maximal sample size: ).","code":"R> `n(X_1)`      <- ConditionalSampleSize() R> `E[n(X_1)^2]` <- expected(composite({`n(X_1)`^2}), +                            data_distribution = datadist, +                            prior = prior) R> opt3 <- minimize(composite({`E[n(X_1)^2]` - 200000*epower}), +                   subject_to(toer <= 0.025), initial_design) R> evaluate(epower, opt3$design)"},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:CP_constraint","dir":"Articles","previous_headings":"Examples","what":"Conditional power constraint","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"adoptr also allows incorporation hard constraints conditional scores conditional power. Conditional power constraints intuitively sensible make sure trial continues second stage maintains high chance rejecting null hypothesis end. example, return case point prior effect size. , power derived expected score corresponding conditional power. conditional power constraint added exactly way unconditional constraints. Comparing optimal design computed constraints without conditional power constraint (cf.¬†beginning chapter), optimal design additional constraint requires larger sample sizes regions conditional power usually given threshold. Overall, additional constraint reduces feasible solution space consequently increases expected sample size ( conditional power constraint vs.¬†without). example demonstrates, additional binding conditional constraints come costs global optimality. Whether loss unconditional performance outweighed appealing conditional properties must decided case case basis.","code":"R> prior <- PointMassPrior(theta = .3, mass = 1.0) R> ess   <- ExpectedSampleSize(dist = datadist, prior = prior) R> cp    <- ConditionalPower(dist = datadist, prior = prior) R> power <- expected(cp, data_distribution = datadist, prior = prior) R> opt4 <- minimize(ess, subject_to(toer <= 0.025, power >= 0.9, cp >= 0.8), +                   initial_design)"},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:make_fixed","dir":"Articles","previous_headings":"Examples","what":"Keeping design parameters fixed","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"clinical practice, non-statistical considerations may impose direct constraints design parameters. instance, sponsor might subject logistical constraints render necessary design trial specific stage one sample size. Returning standard case discussed Section 6.1, assume stage-one per-group sample size exactly 80 individuals per group required (n1=80n_1 = 80) instead optimal value $n_1^* = $. Furthermore, assume sponsor wants stop early futility negative effect size interim analysis, .e., c1f=0c_1^f = 0. adoptr supports considerations allowing fix specific values design: ‚Äòfixed‚Äô parameter kept constant optimization. Note also possible ‚Äòun-fix‚Äô parameters using make_tunable function. following figure visually compares original design new, restricted design. designs qualitatively similar, fixing n1n_1 c1fc_1^f come price slightly increased expected sample size ( compared less restricted case).","code":"R> initial_design@n1  <- 80 R> initial_design@c1f <- 0 R> initial_design     <- make_fixed(initial_design, n1, c1f) R> opt5 <- minimize(ess, subject_to(toer <= 0.025, power >= 0.9), +                   initial_design)"},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"sec:validation","dir":"Articles","previous_headings":"","what":"Validation concept","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"conduct analysis clinical trials highly regulated process. essential requirement put forward Title 21 CRF (code federal regulations) Part 11 need validate software used work produce records (US Food Drug Administration others 2003). exact scope regulations CRF 11 sometimes difficult assess, always clear regulations apply R packages used production environment (R Foundation Statistical Computing 2013). Irrespective applicability CRF 11 adoptr, design clinical trial undoubtedly crucial package authors provide extensive evidence correctness package functionality. Additionally, evidence easily accessible human-readable. latter requirement consequence fact , following CRF 11 remarks R Foundation Statistical Computing (2013), ‚Äòvalidated R-package‚Äô exist since validation process must always implemented responsible user. facilitate process validation much possible, adoptr implements following measures: Open-source development: entire development adoptr organized around public GitHub.com repository (https://github.com/optad/adoptr). Anybody can freely download source code, browse development history, raise issues, contribute code base opening pull requests. CRAN releases: Regular CRAN (CRAN 2020) releases updated versions maximize visibility add additional layer testing quality control. New features can implemented tested (public) development version GitHub pushing new releases CRAN. Unit testing: adoptr implements extensive test suite using package testthat (H. Wickham, R Studio, R Core Team (2018), H. Wickham (2011)) allows spotting new errors early development localizing quickly. Together continuous integration (cf.¬†), helps improve quality speeds development process. Continuous Integration / Continuous Deployment: adoptr makes extensive use continuous integration deployment services GitHub Actions (GitHub.com 2021). new commit public GitHub.com repository immediately run automated testing pipeline. Merges main branch possible tests passed successfully contributor reviewed approved changes (‚Äòbranch protection system‚Äô). Continuous deployment allows automatically updating code-coverage statistics (cf.¬†) --date online documentation (cf.¬†). Coverage analyses: document extent test suite covers package code, adoptr relies codecov (Codecov LLC 2020) online service conjunction covr package (Hester 2019). provides statistics proportion lines visited least testing (currently 100%) enables easy online publication results. Online documentation: Beyond standard documentation generated using roxygen2 (Hadley Wickham et al. 2019), also make use pkgdown (H. Wickham Hesselberth 2019) package free GitHub pages service publish static html version documentation online https://optad.github.io/adoptr/. includes function reference vignettes consistent easily accessible format. online documentation experience improved integration full-text docsearch engine (https://www.algolia.com/ref/docsearch). Extended validation report: limits can done standard unit testing framework within package (cf.¬†https://cran.r-project.org/web/packages/policies.html). Long-running test suites also hinder active development strict continuous integration continuous deployment (CI/CD) workflow since changes main branch require passing automated tests. , therefore, decided restrict internal unit tests bare minimum clear focus coverage technical integrity package. demonstrate correctness results larger set examples comparison existing packages rpact, implemented external ‚Äòvalidation report‚Äô (sources: https://github.com/optad/adoptr-validation-report, current report: https://optad.github.io/adoptr-validation-report/) using bookdown (Xie (2019), Xie (2016)) package. report uses CI/CD daily rebuilds automatically deploy report corresponding current CRAN-hosted version package. Within report, still use testthat conduct formal tests. case tests fails, build report fail, maintainers get notified, status indicator repository changes. Validating software employed may well much work developing first place. opaque requirements lack adequate tools automate validation tasks major hurdle academic developers address validation issues. additional work, however, worth since improves quality also facilitates collaboration makes easier promote packages real-world use.","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"future-work","dir":"Articles","previous_headings":"","what":"Future work","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"main motivation implementing adoptr R fact far common programming language used target audience. Note, however, using R generic nonlinear constraint optimization problems leads performance bottleneck since currently stable efficient way obtaining gradient information generic, user-defined functions. Since one design principles adoptr extensibility, ability support custom objective functions central. R, implies one resort either finite differences approximation first- second-order derivatives completely gradient-free optimizer COBYLA. experiments, found COBYLA far stable finite-differences augmented Lagrangian method (data shown). Still, problems, convergence using COBYLA rather slow. interesting alternative R nloptr therefore Julia (Bezanson et al. 2017) JuMP framework numerical programming (Lubin Dunning 2015). framework allows interfacing generic nonlinear solvers via common interface , leveraging Julia‚Äôs excellent automatic-differentiation capabilities, able provide fast precise (second-order) gradient information user-defined objective functions.","code":""},{"path":"https://optad.github.io/adoptr/articles/adoptr_jss.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R","text":"first two authors contributed equally manuscript. work partly supported Deutsche Forschungsgemeinschaft Grant number KI 708/4-1.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/articles/composite-scores.html","id":"functional-composition","dir":"Articles","previous_headings":"","what":"Functional Composition","title":"Composite Scores","text":"Composite scores restricted linear operations support valid numerical expression: Even control flow supported: real constraint expression must vectorized.","code":"cs <- composite({log(css) - 50*sin(cp)}) evaluate(cs, design, c(0, .5, 1)) #> [1] -36.55135 -36.55192 -36.55205 cs <- composite({   res <- 0   for (i in 1:3) {     res <- res + css   }   res }) evaluate(cs, design, c(0, .5, 1)) #> [1] 750 750 750"},{"path":"https://optad.github.io/adoptr/articles/conditional-scores.html","id":"unconditional-scores-in-adoptr","dir":"Articles","previous_headings":"","what":"(Un)conditional Scores in adoptr","title":"Conditional Scores and Constraints","text":"two fundamental ways scoring two-stage design: First, one may assess performance observing data, .e., planning stage. Classical examples scores power, type-one-error rate, expected sample size. , however, second perspective. observing stage-one outcome, one might inclined consider conditional properties design. prominent example conditional power (probability reject null alternative given stage-one outcome). consider following example design  adoptr, scores instances respective score class. important ones : ConditionalScore, UnconditionalScore, IntegralScore. object class ConditionalScore can evaluate design particular stage-one outcome. ConditionalScore function s(ùíü,x1)s(\\mathcal{D}, x_1) evaluating design ùíü\\mathcal{D} stage-one outcome X1=x1X_1 = x_1. conditional scores might depend data distribution (conditional power) others (conditional sample size). Conditional score evaluation completely vectorized: Conditional scores can also plotted directly given design including plot() call.  conditional score can integrated respect prior data distribution obtain unconditional score. Note conditional scores depend specification distributions (e.g., conditional power) arguments must consistent! resulting score class IntegralScore, specific subclass UnconditionalScore evaluates designs independent particular x1x_1, .e., unconditionally Power point alternative can obtained forming expected value respect point prior. convenience, include constructor power directly, e.g., variants equivalent give power 0.40.4. Similarly, ExpectedSampleSize shorthand constructor expected conditional sample size, .e., overall expected sample size:","code":"design <- TwoStageDesign(     n1        = 100,     c1f       = .0,     c1e       = 2.0,     n2_pivots = rep(150, 5),     c2_pivots = sapply(1 + adoptr:::GaussLegendreRule(5)$nodes, function(x) -x + 2) ) plot(design) uniform_prior <- ContinuousPrior(   function(x) numeric(length(x)) + 1/.2,   support = c(.3, .5) )  cp  <- ConditionalPower(Normal(), uniform_prior) css <- ConditionalSampleSize()  x1  <- c(0, .5, 1) evaluate(cp, design, x1) #> [1] 0.8312538 0.9303985 0.9772962 evaluate(css, design, x1) #> [1] 250 250 250 plot(design, \"Conditional Power\" = cp) ep <- expected(cp, Normal(), uniform_prior) evaluate(ep, design) #> [1] 0.989392 power1 <- expected(   ConditionalPower(Normal(), PointMassPrior(.4, 1.0)),   Normal(), PointMassPrior(.4, 1.0) ) power2 <- Power(Normal(), PointMassPrior(.4, 1.0))  evaluate(power1, design) #> [1] 0.9967857 evaluate(power2, design) #> [1] 0.9967857 ess1 <- expected(ConditionalSampleSize(), Normal(), uniform_prior) ess2 <- ExpectedSampleSize(Normal(), uniform_prior)  evaluate(ess1, design) #> [1] 134.9135 evaluate(ess2, design) #> [1] 134.9135"},{"path":"https://optad.github.io/adoptr/articles/conditional-scores.html","id":"conditional-constraints","dir":"Articles","previous_headings":"","what":"Conditional Constraints","title":"Conditional Scores and Constraints","text":"syntax constraint specification unconditional constraints (power etc.) can used conditional scores (e.g.¬†conditional power) well. Currently, constraints apply continuation area . E.g., imposes constraint minimal conditional power upon continuation. Inter-score comparisons also supported, e.g. enforce conditional power always larger conditional error.","code":"cp >= 0.7 #> -Pr[x2>=c2(x1)|x1] (x1) <= -0.7 for x1 in [c1f,c1e] cp >= ConditionalPower(Normal(), PointMassPrior(0, 1)) #> Pr[x2>=c2(x1)|x1]  - Pr[x2>=c2(x1)|x1] (x1) <= 0 for x1 in [c1f,c1e]"},{"path":"https://optad.github.io/adoptr/articles/other-endpoints.html","id":"binary-endpoints","dir":"Articles","previous_headings":"","what":"Binary endpoints","title":"Designs for non-normal Endpoints with approximately normal test statistics","text":"Binary endpoints endpoints individual observations follow Bernoulli distribution, .e.¬†XiT‚àºBin(1,pT)X_i^T \\sim Bin(1,p_T) XiC‚àºBin(1,pC)X_i^C\\sim Bin(1,p_C). goal compare probability pTp_T event treatment group fixed value (single-arm trial) probability pCp_C event control group (two-armed trial). Thus, assuming larger probabilities favorable, H0:pT‚â§pCvs.H1:pT>pC. H_0: p_T \\leq p_C\\quad \\text{vs.} \\quad H_1:p_T > p_C. test hypothesis, one use test statistic U=n2pÃÇT‚àípÃÇCpÃÇ0(1‚àípÃÇ0), U=\\sqrt{\\frac{n}{2}}\\frac{\\hat{p}_T-\\hat{p}_C}{\\sqrt{\\hat{p}_0(1-\\hat{p}_0)}}, pÃÇT=1n‚àëinXiT\\hat{p}_T=\\frac{1}{n}\\sum_i^{n}X_i^T pÃÇC=1n‚àëinXiC\\hat{p}_C=\\frac{1}{n}\\sum_i^{n}X_i^C maximum likelihood estimators pTp_T pCp_C pÃÇ0=1n‚àëinXiT+1n‚àëinXiC2\\hat{p}_0=\\frac{\\frac{1}{n}\\sum_i^{n}X_i^T+\\frac{1}{n}\\sum_i^{n}X_i^C}{2}. outcome UU compared cfc_f cec_e, first stage boundaries. U‚àà[cf,ce]U\\[c_f,c_e], continue trial compute new value U2U_2 second stage, reject null U2>c2U_2>c_2. well-known fact test statistic asymptotically normal, give proof next section.","code":""},{"path":"https://optad.github.io/adoptr/articles/other-endpoints.html","id":"asymptotic-distribution-of-the-test-statistic","dir":"Articles","previous_headings":"Binary endpoints","what":"Asymptotic distribution of the test statistic","title":"Designs for non-normal Endpoints with approximately normal test statistics","text":"begin difference pÃÇT‚àípÃÇC\\hat{p}_T-\\hat{p}_C. Using de Moivre-Laplace theorem, get npÃÇT‚àínpTn‚Üídùí©(0,pT(1‚àípT)). \\frac{n\\hat{p}_T-np_T}{\\sqrt{n}} \\overset{d}{\\} \\mathcal{N}(0,p_T(1-p_T)).  defining œÉA2=pT(1‚àípT)+pC(1‚àípC)\\sigma_A^2=p_T(1-p_T)+p_C(1-p_C), obtain npÃÇT‚àínpTn‚àínpÃÇC‚àínpCn=n(pÃÇT‚àípÃÇC‚àí(pT‚àípC))‚Üídùí©(0,œÉA2), \\frac{n\\hat{p}_T-np_T}{\\sqrt{n}}-\\frac{n\\hat{p}_C-np_C}{\\sqrt{n}}=\\sqrt{n}(\\hat{p}_T-\\hat{p}_C-(p_T-p_C))\\overset{d}{\\}\\mathcal{N}(0,\\sigma_A^2),  follows n(pÃÇT‚àípÃÇC)‚Üídùí©(n(pT‚àípc),œÉA2). \\sqrt{n}(\\hat{p}_T-\\hat{p}_C)\\overset{d}{\\}\\mathcal{N}(\\sqrt{n}(p_T-p_c),\\sigma_A^2).  Applying continuous mapping theorem, results œÉÃÇ0:=2pÃÇ0(1‚àípÃÇ0)‚ÜíP2p0(1‚àíp0):=œÉ0\\hat{\\sigma}_0:=\\sqrt{2\\hat{p}_0(1-\\hat{p}_0)} \\overset{P}{\\}\\sqrt{2p_0(1-p_0)}:=\\sigma_0, Slutzky‚Äôs theorem, get n(pÃÇT‚àípÃÇC)œÉ0=n2pÃÇT‚àípÃÇCpÃÇ0(1‚àípÃÇ0)‚Üídùí©(npT‚àípCœÉ0,œÉA2œÉ02). \\frac{\\sqrt{n}(\\hat{p}_T-\\hat{p}_C)}{\\sigma_0}=\\sqrt{\\frac{n}{2}}\\frac{\\hat{p}_T-\\hat{p}_C}{\\sqrt{\\hat{p}_0(1-\\hat{p}_0)}}\\overset{d}{\\}\\mathcal{N}\\left(\\sqrt{n}\\frac{p_T-p_C}{\\sigma_0},\\frac{\\sigma_A^2}{\\sigma_0^2}\\right).  Hence, sufficiently large nn, UU approximately normal. Note null hypothesis, œÉA2=œÉ02\\sigma_A^2=\\sigma_0^2 pT=pCp_T=p_C. Thus, approximately, U‚àºùí©(0,1)U\\sim \\mathcal{N}(0,1) H0H_0.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/articles/other-endpoints.html","id":"implementation-details","dir":"Articles","previous_headings":"Binary endpoints > adoptr and binomial endpoints","what":"Implementation details","title":"Designs for non-normal Endpoints with approximately normal test statistics","text":"Currently, adoptr supports specification single fixed reference value fo pCp_C, general prior distributions supported effect size Œ∏\\theta. limitation, uncertainty control group rate represented framework. However, trial comparing new treatment existing one, usually reasonable assume information event rate control group available beforehand.","code":""},{"path":"https://optad.github.io/adoptr/articles/other-endpoints.html","id":"example","dir":"Articles","previous_headings":"Binary endpoints > adoptr and binomial endpoints","what":"Example","title":"Designs for non-normal Endpoints with approximately normal test statistics","text":"Assume want plan two-armed trial assumed rate events control group pC=0.3p_C=0.3. parameters encoded DataDistribution object. Let us furthermore postulate normal prior distribution Œ∏\\theta expectation Œº=0.2\\mu=0.2 standard deviation œÉ=0.2\\sigma=0.2, truncated interval (‚àí.29,0.69)(-.29,0.69). necessary use truncation ensure pT‚àà(0,1)p_T \\(0,1). require maximal type one error Œ±‚â§0.025\\alpha\\leq 0.025 minimum expected power ùîº[1‚àíŒ≤]‚â•0.8\\mathbb{E}[1-\\beta]\\geq 0.8. Next, need choose objective function, expected sample size chosen prior distribution Œ∏\\theta example. chosen starting point optimization procedure, use minimize function determine optimal design parameters.","code":"datadist <- Binomial(0.3, two_armed = TRUE) H_0        <- PointMassPrior(.0, 1) prior      <- ContinuousPrior(function(x) 1 / (pnorm(0.69, 0.2, 0.2) -                                                     pnorm(-0.29, 0.2, 0.2)) *                                    dnorm(x, 0.2, 0.2),                               support = c(-0.29,0.69),                               tighten_support = TRUE) alpha      <- 0.025 min_epower <- 0.8 toer_cnstr <- Power(datadist, H_0) <= alpha epow_cnstr <- Power(datadist, condition(prior, c(0.0,0.69))) >= min_epower ess <- ExpectedSampleSize(datadist,prior)  init <- get_initial_design(0.2,0.025,0.2)  opt_design <- minimize(ess,subject_to(toer_cnstr,epow_cnstr),                         initial_design = init, check_constraints = TRUE) #> Warning in minimize(ess, subject_to(toer_cnstr, epow_cnstr), initial_design = #> init, : NLOPT_MAXEVAL_REACHED: Optimization stopped because maxeval (above) was #> reached.  plot(opt_design$design)"},{"path":"https://optad.github.io/adoptr/articles/other-endpoints.html","id":"time-to-event-endpoints","dir":"Articles","previous_headings":"","what":"Time-to-event endpoints","title":"Designs for non-normal Endpoints with approximately normal test statistics","text":"Time--event endpoints another common type endpoint used clinical trials. Time--event data two-dimensional consists indicator denoting occurrence event censoring, time event censoring. common effect measure time--event endpoints called hazard-ratio, ratio hazard functions two groups ratio hazard one group postulated baseline hazard. following, hazard ratio denoted Œ∏:=ŒªC(t)ŒªT(t)\\theta := \\frac{\\lambda_C(t)}{\\lambda_T(t)}, assume Œ∏\\theta constant time. Assuming less hazard favorable, resulting hypotheses tested H0:Œ∏‚â§1vs.H1:Œ∏>1. H_0: \\theta\\leq 1 \\quad \\text{vs.} \\quad H_1: \\theta >1. Let 1,‚Ä¶,J1,\\dots,J distinct times observed events either group let nT,j,nC,jn_{T,j}, n_{C,j} number subjects, neither event censored. Additionally, let OT,j,OC,jO_{T,j},O_{C,j} denote observed number events time jj. following assume ties, OT,j,OC,j‚àà{0,1}O_{T,j},O_{C,j}\\\\{0,1\\}. Define nj:=nT,j+nC,jn_j:=n_{T,j}+n_{C,j} Oj:=OT,j+OC,jO_j:= O_{T,j}+O_{C,j}. null, hazard functions groups equal. Thus, ‚àà{T,C}\\\\{T,C\\}, Oi,jO_{,j} can regarded number events draw size ni,jn_{,j}, population size njn_j. Therefore, Oi,jO_{,j} follows hypergeometric distribution, .e.¬†Oi,j‚àºh(nj,Oj,ni,j)O_{,j}\\sim h(n_j,O_j,n_{,j}). distribution expected value Ei,j:=ùîº[Oi,j]=ni,jOjnjE_{,j}:=\\mathbb{E}[O_{,j}]=n_{,j}\\frac{O_j}{n_j} variance Vi,j:=Var(Oi,j)=Ei,j(nj‚àíOjnj)(nj‚àíni,jnj‚àí1)V_{,j}:=\\text{Var}(O_{,j})=E_{,j}\\left(\\frac{n_j-O_j}{n_j}\\right)\\left(\\frac{n_j-n_{,j}}{n_j-1}\\right). Using definitions, can define -called log-rank test statistic L=LT:=‚àëj=1JOT,j‚àíET,j‚àëj=1JVT,j. L=L_T:=\\frac{\\sum_{j=1}^J O_{T,j}-E_{T,j}}{\\sqrt{\\sum_{j=1}^J V_{T,j}}}.  Note matter whether consider LTL_T analogously defined statistic LCL_C, yield results, abbreviate LTL_T LL. central limit theorem, easy see L‚Üídùí©(0,1)L \\overset{d}{\\} \\mathcal{N}(0,1). alternative, can shown , approximately, L‚àºùí©(log(Œ∏)12J,1)L \\sim \\mathcal{N}(\\text{log}(\\theta)\\frac{1}{2}\\sqrt{J},1). œà\\psi average probability event per recruit arms (also known event rate), JJ can replaced 2‚ãÖn‚ãÖœà2 \\cdot n \\cdot \\psi (nn denotes, like previous sections, number recruits per group). Thus, postulating event probability, can calculate number recruits per groups required achieve specific number events, extensions, specific power. adoptr, parameter œà\\psi needs pre-specified order obtain one-parametric distribution (parameter Œ∏\\theta), œà\\psi assumed fixed time. similar case binary endpoints, response rate control group pCp_C constant value.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/articles/other-endpoints.html","id":"notation","dir":"Articles","previous_headings":"Time-to-event endpoints > Survival analysis and adaptive designs","what":"Notation","title":"Designs for non-normal Endpoints with approximately normal test statistics","text":"expand previous notation index k‚àà{1,2}k\\\\{1,2\\} denoting current stage. observe d1d_1 events interim analysis times {1,‚Ä¶,J1}\\{1,\\dots,J_1\\}, observe d2d_2 events total final analysis times {1,‚Ä¶,J2}\\{1,\\dots,J_2\\}. stress , notation, d2d_2 denotes cumulative number events stages. Furthermore, let Oi,j,kO_{,j,k} number observed events arm ‚àà{T,C}\\\\{T,C\\} time j‚àà{1,‚Ä¶,Jk}j \\\\{1,\\dots,J_k\\} stage k‚àà{1,2}k \\\\{1,2\\}. Like previous section, let Ei,j,k=ùîº[Oi,j,k]=ni,j,kOj,knj,kE_{,j,k}= \\mathbb{E}[O_{,j,k}]=n_{,j,k}\\frac{O_{j,k}}{n_{j,k}}, ni,j,kn_{,j,k} number patients event end stage kk, let Oj,k=OT,j,k+OC,j,kO_{j,k}=O_{T,j,k}+O_{C,j,k} nj,k=nT,j,k+nC,j,kn_{j,k}=n_{T,j,k}+n_{C,j,k}. Likewise, can define Vi,j,kV_{,j,k} analogously previous section. cumulative log-rank test statistic stage k‚àà{1,2}k \\\\{1, 2\\} can defined Lk=‚àëj=1JkOT,j,k‚àíET,j,k‚àëj=1JkVT,j,k. L_k=\\frac{\\sum_{j=1}^{J_k} O_{T,j,k}-E_{T,j,k}}{\\sqrt{\\sum_{j=1}^{J_k} V_{T,j,k}}}.","code":""},{"path":"https://optad.github.io/adoptr/articles/other-endpoints.html","id":"dependency-issues-and-solutions","dir":"Articles","previous_headings":"Time-to-event endpoints > Survival analysis and adaptive designs","what":"Dependency issues and solutions","title":"Designs for non-normal Endpoints with approximately normal test statistics","text":"normal distributed endpoints, stage-wise test statistics come independent cohorts, makes calculation joint distributions straightforward. survival analysis, possible patients recruited first stage, event point interim analysis. provide information stages: first stage, know survived, second stage, might die even survive end trial. makes construction pair suitable test statistics challenging. following, present two methods avoid issues.","code":""},{"path":"https://optad.github.io/adoptr/articles/other-endpoints.html","id":"solution-1-independent-increments","dir":"Articles","previous_headings":"Time-to-event endpoints > Survival analysis and adaptive designs > Dependency issues and solutions","what":"Solution 1: Independent increments","title":"Designs for non-normal Endpoints with approximately normal test statistics","text":"can shown statistic Z2:=d2L2‚àíd1L1d2‚àíd1 Z_2:= \\frac{\\sqrt{d_2}L_2-\\sqrt{d_1}L_1}{\\sqrt{d_2-d_1}}  approximately distributed according ùí©(log(Œ∏)12d2‚àíd1,1)\\mathcal{N}(\\text{log}(\\theta)\\frac{1}{2}\\sqrt{d_2-d_1},1), L1L_1 Z2Z_2 approximately independent. recruitment testing procedure now follows: accrual time, recruit approximately d12œà\\frac{d_1}{2\\psi} patients per group conduct interim analysis observed d1d_1 events overall. Assume, qq patients event interim analysis. patients censored computation L1L_1. L1L_1 compared futility efficacy boundaries cfc_f cec_e, recruitment stopped L1<cfL_1 < c_f L1>ceL_1 > c_e. cf‚â§L1‚â§cec_f \\leq L_1 \\leq c_e, recruitment patients second stage continue. number patients recruited second stage calculated d2(L1)d_2(L_1) events expected observed second stage. Similarly normal case, required number events function first-stage test statistic. observation d2(L1)d_2(L_1) events trigger conduct final analysis, Z2Z_2 compared c2(L1)c_2(L_1).","code":""},{"path":"https://optad.github.io/adoptr/articles/other-endpoints.html","id":"solution-2-left-truncation-at-the-second-stage","dir":"Articles","previous_headings":"Time-to-event endpoints > Survival analysis and adaptive designs > Dependency issues and solutions","what":"Solution 2: Left truncation at the second stage","title":"Designs for non-normal Endpoints with approximately normal test statistics","text":"Another approach uses left truncation right censoring. following, RiR_i stands calendar time entry individual ii. Furthermore, let TiT_i time entry event CiC_i time entry censoring. Assume values independent let ri,ti,cir_i,t_i,c_i realizations Ri,TiR_i,T_i CiC_i. Additionally, denote calendar time interim analysis tIntt_{Int} calender time final analysis tFint_{Fin}. Let individual ii recruited interim analysis. Define yi,1:=min{ti,ci,tInt}y_{,1}:=\\min \\{t_i,c_i,t_{Int}\\}, .e.¬†yi,1y_{,1} can interpreted minimum time ‚Äúsomething‚Äù happens individual ii first stage (either interim analysis conducted, ii event censored). risk interval first-stage test statistic now defined (0,yi,1)(0,y_{,1}), means individual ii belongs risk set event time tjt_j min{ci,tInt‚àíri}‚â•xj\\min \\{c_i,t_{Int}-r_i\\}\\geq x_j. ii event yet first stage, lost follow-yet first stage, recruited second stage, define yi,2:=min{ti,ci,tFin}y_{,2}:=\\min\\{t_i,c_i,t_{Fin}\\}. , yi,2y_{,2} can interpreted minimum time something happens individual ii second stage: Either final analysis conducted, ii event censored. risk interval individual ii second stage test-statistic defined (max(tInt‚àíri,0),yi,2)(\\max(t_{Int}-r_i, 0),y_{,2}). definition takes account patient jj recruited first stage, event interim analysis, already provided information ‚Äúevent‚Äù time span (0,tInt‚àíri)(0, t_{Int}-r_i) interim analysis. avoid double-counting second analysis, say patient risk set time span . Using idea, one can conduct analyses trial according following instructions: interim analysis, procedure independent increment solution, .e.¬†L1L_1 computed usual way compared futility efficacy boundaries cfc_f cec_e. L1‚àà[ce,cf]L_1 \\[c_e,c_f] (.e.¬†trial stopped early efficacy futility), continue observation recruit new patients, d2(L1)d_2(L_1) events expected observed second stage. second-stage test statistic two methods differ. , idea construct log-rank test statistic LTruncL_{Trunc} comprised data patients recruited interim analysis, contribute test statistic usual way, patients recruited interim analysis event yet, contribute left (possibly right) truncated datapoints. theory, can achieved appropriately adjusting njn_j respective event timings jj definition log-rank statistic, practice, survival::coxph method can handle datasets aforementioned structure.","code":""},{"path":"https://optad.github.io/adoptr/articles/other-endpoints.html","id":"example-1","dir":"Articles","previous_headings":"Time-to-event endpoints > Survival analysis and adaptive designs > Dependency issues and solutions","what":"Example","title":"Designs for non-normal Endpoints with approximately normal test statistics","text":"adoptr, trial designs investigate time--event endpoints can represented objects class TwoStageDesignSurvival. designs consist slots first stage efficacy futility boundaries cf ce, slot required number events first stage n1, slots spline interpolation points n2 c2 functions, postulated event rate œà\\psi. Two things important note : First, functions n1 n2 return number required events, number recruits required achieve number events expectation. Information latter instead provided summary output design. Second, one-armed trials, n1 n2 overall number required events, two-armed trials, n1 n2 return half overall number required events. analogous case normally distributed outcomes, n1 n2 return group-wise sample sizes. However, calling n1 n2 group-wise number events misnomer, timings interim analyses based overall number events, number events unlikely exactly equal across two groups. Let us say want plan two-armed trial trial, assume average rate events œà=0.7\\psi=0.7. postulated rate events œà\\psi saved DataDistribution object handed design optimized respect distribution. used convert required number events dd estimated number required recruits via dœà\\frac{d}{\\psi}, uses. design parameters invariant respect choice œà\\psi. Effect sizes time--event trials formulated respect hazard ratio. example, assume Œ∏=1\\theta=1 null hypothesis, point alternative hypothesis Œ∏=1.7\\theta=1.7. desired design maximal type error Œ±‚â§0.025\\alpha\\leq 0.025 minimum power (1‚àíŒ≤)‚â•0.8(1-\\beta)\\geq 0.8. noted number required events 2‚ãÖ2\\cdotnevs1 2‚ãÖ2\\cdotnevs2(x1) important information thresholds adhered testing purposes. nrec1 nrec2(x1) serve rough estimates required number recruits achieve target number events. additional information e.g.¬†time-dependence baseline hazards available, may worthwhile use sophisticated approach dœà\\frac{d}{\\psi} formula estimate number required subjects.","code":"datadist <- Survival(0.7, two_armed = TRUE) H_0 <- PointMassPrior(1, 1) H_1 <- PointMassPrior(1.7, 1) alpha <- 0.025 min_power <- 0.8 toer_con <- Power(datadist,H_0) <= alpha pow_con <- Power(datadist,H_1) >= min_power exp_no_events <- ExpectedNumberOfEvents(datadist, H_1) init <- get_initial_design(1.7, 0.025, 0.2, dist=datadist) opt_survival <- minimize(exp_no_events, subject_to(toer_con,pow_con),                          initial_design = init, check_constraints=TRUE)  summary(opt_survival$design) #> For two-armed trials: nevs denotes half of the overall number of required events. nrec denotes the resulting group-wise sample size. #>  #> TwoStageDesignSurvival: nevs1= 32 --> nrec1= 46 #>           futility |                  continue                 | efficacy #>       x1:     0.79 |  0.83  0.98  1.24  1.54  1.85  2.10  2.25 |  2.29 #>   c2(x1):     +Inf | +2.17 +2.02 +1.77 +1.43 +1.00 +0.52 +0.07 |  -Inf #>   nevs2(x1):     0 |    45    42    38    32    24    17    12 |     0 #>   nrec2(x1):     0 |    64    60    54    45    35    25    17 |     0 #>"},{"path":"https://optad.github.io/adoptr/articles/working-with-priors.html","id":"discrete-priors","dir":"Articles","previous_headings":"","what":"Discrete priors","title":"Working with priors","text":"simplest supported prior class discrete PointMassPrior priors. specify discrete prior, one simply specifies vector pivot points positive mass vector corresponding probability masses. E.g., consider example point Œ¥=0.1\\delta = 0.1 probability mass 0.40.4 point Œ¥=0.25\\delta = 0.25 mass 1‚àí0.4=0.61 - 0.4 = 0.6. details provided methods, see ?DiscretePrior.","code":"disc_prior <- PointMassPrior(c(0.1, 0.25), c(0.4, 0.6))"},{"path":"https://optad.github.io/adoptr/articles/working-with-priors.html","id":"continuous-priors","dir":"Articles","previous_headings":"","what":"Continuous priors","title":"Working with priors","text":"adoptr also supports arbitrary continuous priors support compact intervals. instance, consider prior based truncated normal via: details provided methods, see ?ContinuousPrior.","code":"cont_prior <- ContinuousPrior(   pdf     = function(x) dnorm(x, mean = 0.3, sd = 0.2),    support = c(-2, 3) )"},{"path":"https://optad.github.io/adoptr/articles/working-with-priors.html","id":"conditioning","dir":"Articles","previous_headings":"","what":"Conditioning","title":"Working with priors","text":"practice, important operation conditioning. important implement type one type two error rate constraints. Consider, e.g., case power. Typically, power constraint imposed single point alternative, e.g.¬†using constraint uncertainty true response rate incorporated design, makes sense assume continuous prior Œ∏\\theta. case, prior conditioned power constraint avoid integrating null hypothesis:","code":"Power(Normal(), PointMassPrior(.4, 1)) >= 0.8 #> -Pr[x2>=c2(x1)]  <= -0.8 Power(Normal(), condition(cont_prior, c(0, 3))) >= 0.8 #> -Pr[x2>=c2(x1)]  <= -0.8"},{"path":"https://optad.github.io/adoptr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kevin Kunzmann. Author, copyright holder. Maximilian Pilz. Author, maintainer. Jan Meis. Author. Nico Bruder. Author.","code":""},{"path":"https://optad.github.io/adoptr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kunzmann K, Pilz M, Herrmann C, Rauch G, Kieser M (2021). ‚Äúadoptr Package: Adaptive Optimal Designs Clinical Trials R.‚Äù Journal Statistical Software, 98(9), 1‚Äì21. doi:10.18637/jss.v098.i09.","code":"@Article{,   title = {The {adoptr} Package: Adaptive Optimal Designs for Clinical Trials in {R}},   author = {Kevin Kunzmann and Maximilian Pilz and Carolin Herrmann and Geraldine Rauch and Meinhard Kieser},   journal = {Journal of Statistical Software},   year = {2021},   volume = {98},   number = {9},   pages = {1--21},   doi = {10.18637/jss.v098.i09}, }"},{"path":"https://optad.github.io/adoptr/index.html","id":"adoptr-","dir":"","previous_headings":"","what":"Adaptive Optimal Two-Stage Designs","title":"Adaptive Optimal Two-Stage Designs","text":"Adaptive optimal two-stage designs clinical trials one two arms. details core theoretical background, see: Pilz M, Kunzmann K, Herrmann C, Rauch G, Kieser M. variational approach optimal two-stage designs. Statistics Medicine. 2019;38(21):4159‚Äì4171. https://doi.org/10.1002/sim.8291","code":""},{"path":"https://optad.github.io/adoptr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Adaptive Optimal Two-Stage Designs","text":"Install latest CRAN release via development version directly GitHub :","code":"install.packages(\"adoptr\") devtools::install_github(\"optad/adoptr\")"},{"path":"https://optad.github.io/adoptr/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Adaptive Optimal Two-Stage Designs","text":"documentation hosted https://optad.github.io/adoptr.","code":""},{"path":"https://optad.github.io/adoptr/index.html","id":"validation-report","dir":"","previous_headings":"","what":"Validation Report","title":"Adaptive Optimal Two-Stage Designs","text":"provide extensive validation report adoptr implemented using bookdown package. sources available https://github.com/optad/adoptr-validation-report last build version hosted https://optad.github.io/adoptr-validation-report.","code":""},{"path":"https://optad.github.io/adoptr/reference/ANOVA-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Analysis of Variance ‚Äî ANOVA-class","title":"Analysis of Variance ‚Äî ANOVA-class","text":"ANOVA used test whether significant difference means groups. sample size adoptr returns group wise sample size. function get_tau_ANOVA used obtain parameter \\(\\tau\\), used way \\(\\theta\\) describe difference means groups.","code":""},{"path":"https://optad.github.io/adoptr/reference/ANOVA-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analysis of Variance ‚Äî ANOVA-class","text":"","code":"ANOVA(n_groups)  get_tau_ANOVA(means, common_sd = 1)"},{"path":"https://optad.github.io/adoptr/reference/ANOVA-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analysis of Variance ‚Äî ANOVA-class","text":"n_groups number groups compared means vector denoting mean per group common_sd standard deviation groups","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/ANOVA-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analysis of Variance ‚Äî ANOVA-class","text":"","code":"model <- ANOVA(3L)  H1 <- PointMassPrior(get_tau_ANOVA(c(0.4, 0.8, 0.5)), 1)"},{"path":"https://optad.github.io/adoptr/reference/AverageN2-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Regularization via L1 norm ‚Äî AverageN2-class","title":"Regularization via L1 norm ‚Äî AverageN2-class","text":"Implements L1-norm design's stage-two sample size function. average stage-two sample size without weighting data distribution computed. can interpreted integration unifrom prior continuation region.","code":""},{"path":"https://optad.github.io/adoptr/reference/AverageN2-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regularization via L1 norm ‚Äî AverageN2-class","text":"","code":"AverageN2(label = NA_character_)  # S4 method for class 'AverageN2,TwoStageDesign' evaluate(s, design, optimization = FALSE, subdivisions = 10000L, ...)"},{"path":"https://optad.github.io/adoptr/reference/AverageN2-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regularization via L1 norm ‚Äî AverageN2-class","text":"label object label (string) s Score object design object optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization. subdivisions number subdivisions use adaptive integration (affects non-optimization code) ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/AverageN2-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Regularization via L1 norm ‚Äî AverageN2-class","text":"object class AverageN2","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/AverageN2-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regularization via L1 norm ‚Äî AverageN2-class","text":"","code":"avn2 <- AverageN2()  evaluate(    AverageN2(),    TwoStageDesign(100, 0.5, 1.5, 60.0, 1.96, order = 5L) ) # 60 #> [1] 60"},{"path":"https://optad.github.io/adoptr/reference/BinomialDataDistribution-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Binomial data distribution ‚Äî Binomial-class","title":"Binomial data distribution ‚Äî Binomial-class","text":"Implements normal approximation test rates. reponse rate control group, rC, specified rate_control. null hypothesis : rE ‚â§ rC, rE denotes response rate invervention group. tested alternative rE > rC. test statistic given X1 = ‚àön (rE - rC) / ‚àö(2  r0 (1-r0)), r0 denotes mean rE rC two-armed case, rE one-armed case.#' priors defined rate difference rE - rC.","code":""},{"path":"https://optad.github.io/adoptr/reference/BinomialDataDistribution-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binomial data distribution ‚Äî Binomial-class","text":"","code":"Binomial(rate_control, two_armed = TRUE)  # S4 method for class 'Binomial' quantile(x, probs, n, theta, ...)  # S4 method for class 'Binomial,numeric' simulate(object, nsim, n, theta, seed = NULL, ...)"},{"path":"https://optad.github.io/adoptr/reference/BinomialDataDistribution-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binomial data distribution ‚Äî Binomial-class","text":"rate_control assumed response rate control group two_armed logical indicating two-armed trial regarded x outcome probs vector probabilities n sample size theta distribution parameter ... optional arguments object object class Binomial nsim number simulation runs seed random seed","code":""},{"path":"https://optad.github.io/adoptr/reference/BinomialDataDistribution-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Binomial data distribution ‚Äî Binomial-class","text":"Note simulate class Binomial simulates normal approximation test statistic.","code":""},{"path":"https://optad.github.io/adoptr/reference/BinomialDataDistribution-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Binomial data distribution ‚Äî Binomial-class","text":"rate_control cf. parameter 'rate_control'","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/BinomialDataDistribution-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Binomial data distribution ‚Äî Binomial-class","text":"","code":"datadist <- Binomial(rate_control = 0.2, two_armed = FALSE)"},{"path":"https://optad.github.io/adoptr/reference/ChiSquaredDataDistribution-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Chi-Squared data distribution ‚Äî ChiSquared-class","title":"Chi-Squared data distribution ‚Äî ChiSquared-class","text":"Implements chi-squared distribution. classes Pearson2xk ZSquared subclasses, used two different situations. Pearson2xK used testing k groups homogeneity response rates. null hypothesis r1=...=rk, alternative exists pair groups differing rates. ZSquared implements square normally distributed random variable mean \\(\\mu\\) standard deviation \\(\\sigma^2\\).","code":""},{"path":"https://optad.github.io/adoptr/reference/ChiSquaredDataDistribution-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chi-Squared data distribution ‚Äî ChiSquared-class","text":"","code":"ChiSquared(df)  # S4 method for class 'ChiSquared' quantile(x, probs, n, theta, ...)  # S4 method for class 'ChiSquared,numeric' simulate(object, nsim, n, theta, seed = NULL, ...)"},{"path":"https://optad.github.io/adoptr/reference/ChiSquaredDataDistribution-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chi-Squared data distribution ‚Äî ChiSquared-class","text":"df number degrees freedom x outcome probs vector probabilities n sample size theta distribution parameter ... optional arguments object object class ChiSquared nsim number simulation runs seed random seed","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/ChiSquaredDataDistribution-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chi-Squared data distribution ‚Äî ChiSquared-class","text":"","code":"datadist <- ChiSquared(df=4)"},{"path":"https://optad.github.io/adoptr/reference/ConditionalPower-class.html","id":null,"dir":"Reference","previous_headings":"","what":"(Conditional) Power of a Design ‚Äî ConditionalPower-class","title":"(Conditional) Power of a Design ‚Äî ConditionalPower-class","text":"score evaluates P[X2 > c2(design, X1) | X1 = x1]. Note distribution X2 posterior predictive observing X1 = x1.","code":""},{"path":"https://optad.github.io/adoptr/reference/ConditionalPower-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"(Conditional) Power of a Design ‚Äî ConditionalPower-class","text":"","code":"ConditionalPower(dist, prior, label = \"Pr[x2>=c2(x1)|x1]\")  Power(dist, prior, label = \"Pr[x2>=c2(x1)]\")  # S4 method for class 'ConditionalPower,TwoStageDesign' evaluate(s, design, x1, optimization = FALSE, ...)"},{"path":"https://optad.github.io/adoptr/reference/ConditionalPower-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"(Conditional) Power of a Design ‚Äî ConditionalPower-class","text":"dist univariate distribution object prior Prior object label object label (string) s Score object design object x1 stage-one test statistic optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization. ... optional arguments","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/ConditionalPower-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"(Conditional) Power of a Design ‚Äî ConditionalPower-class","text":"","code":"prior <- PointMassPrior(.4, 1) cp <- ConditionalPower(Normal(), prior) evaluate(    cp,    TwoStageDesign(50, .0, 2.0, 50, 2.0, order = 5L),    x1 = 1 ) #> [1] 0.5 # these two are equivalent: expected(cp, Normal(), prior) #> E[Pr[x2>=c2(x1)|x1]]<Normal<two-armed>;PointMass<0.40>>  Power(Normal(), prior) #> Pr[x2>=c2(x1)]"},{"path":"https://optad.github.io/adoptr/reference/ConditionalSampleSize-class.html","id":null,"dir":"Reference","previous_headings":"","what":"(Conditional) Sample Size of a Design ‚Äî ConditionalSampleSize-class","title":"(Conditional) Sample Size of a Design ‚Äî ConditionalSampleSize-class","text":"score simply evaluates n(d, x1) design d first-stage outcome x1. data distribution prior relevant integrated.","code":""},{"path":"https://optad.github.io/adoptr/reference/ConditionalSampleSize-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"(Conditional) Sample Size of a Design ‚Äî ConditionalSampleSize-class","text":"","code":"ConditionalSampleSize(label = \"n(x1)\")  ExpectedSampleSize(dist, prior, label = \"E[n(x1)]\")  ExpectedNumberOfEvents(dist, prior, label = \"E[n(x1)]\")  # S4 method for class 'ConditionalSampleSize,TwoStageDesign' evaluate(s, design, x1, optimization = FALSE, ...)"},{"path":"https://optad.github.io/adoptr/reference/ConditionalSampleSize-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"(Conditional) Sample Size of a Design ‚Äî ConditionalSampleSize-class","text":"label object label (string) dist univariate distribution object prior Prior object s Score object design object x1 stage-one test statistic optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization. ... optional arguments","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/ConditionalSampleSize-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"(Conditional) Sample Size of a Design ‚Äî ConditionalSampleSize-class","text":"","code":"design <- TwoStageDesign(50, .0, 2.0, 50, 2.0, order = 5L) prior  <- PointMassPrior(.4, 1)  css   <- ConditionalSampleSize() evaluate(css, design, c(0, .5, 3)) #> [1] 100 100  50  ess   <- ExpectedSampleSize(Normal(), prior) ene <- ExpectedNumberOfEvents(Survival(0.7), PointMassPrior(1.7, 1))  # those two are equivalent evaluate(ess, design) #> [1] 73.86249 evaluate(expected(css, Normal(), prior), design) #> [1] 73.86249"},{"path":"https://optad.github.io/adoptr/reference/Constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Formulating Constraints ‚Äî Constraints","title":"Formulating Constraints ‚Äî Constraints","text":"Conceptually, constraints work similar scores (score can put constraint). Currently,  constraints form 'score <=/>= x', 'x <=/>= score' 'score <=/>= score' admissible.","code":""},{"path":"https://optad.github.io/adoptr/reference/Constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Formulating Constraints ‚Äî Constraints","text":"","code":"# S4 method for class 'Constraint,TwoStageDesign' evaluate(s, design, optimization = FALSE, ...)  # S4 method for class 'ConditionalScore,numeric' e1 <= e2  # S4 method for class 'ConditionalScore,numeric' e1 >= e2  # S4 method for class 'numeric,ConditionalScore' e1 <= e2  # S4 method for class 'numeric,ConditionalScore' e1 >= e2  # S4 method for class 'ConditionalScore,ConditionalScore' e1 <= e2  # S4 method for class 'ConditionalScore,ConditionalScore' e1 >= e2  # S4 method for class 'UnconditionalScore,numeric' e1 <= e2  # S4 method for class 'UnconditionalScore,numeric' e1 >= e2  # S4 method for class 'numeric,UnconditionalScore' e1 <= e2  # S4 method for class 'numeric,UnconditionalScore' e1 >= e2  # S4 method for class 'UnconditionalScore,UnconditionalScore' e1 <= e2  # S4 method for class 'UnconditionalScore,UnconditionalScore' e1 >= e2"},{"path":"https://optad.github.io/adoptr/reference/Constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Formulating Constraints ‚Äî Constraints","text":"s Score object design object optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization. ... optional arguments e1 left hand side (score numeric) e2 right hand side (score numeric)","code":""},{"path":"https://optad.github.io/adoptr/reference/Constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Formulating Constraints ‚Äî Constraints","text":"object class Constraint","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/Constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Formulating Constraints ‚Äî Constraints","text":"","code":"design <- OneStageDesign(50, 1.96)  cp     <- ConditionalPower(Normal(), PointMassPrior(0.4, 1)) pow    <- Power(Normal(), PointMassPrior(0.4, 1))  # unconditional power constraint constraint1 <- pow >= 0.8 evaluate(constraint1, design) #> [1] 0.2840466  # conditional power constraint constraint2 <- cp  >= 0.7 evaluate(constraint2, design, .5) #> [1] 0.7 constraint3 <- 0.7 <= cp # same as constraint2 evaluate(constraint3, design, .5) #> [1] 0.7"},{"path":"https://optad.github.io/adoptr/reference/ContinuousPrior-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Continuous univariate prior distributions ‚Äî ContinuousPrior-class","title":"Continuous univariate prior distributions ‚Äî ContinuousPrior-class","text":"ContinuousPrior sub-class Prior implementing generic representation continuous prior distributions compact interval real line.","code":""},{"path":"https://optad.github.io/adoptr/reference/ContinuousPrior-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Continuous univariate prior distributions ‚Äî ContinuousPrior-class","text":"","code":"ContinuousPrior(   pdf,   support,   order = 10,   label = NA_character_,   tighten_support = FALSE,   check_normalization = TRUE )"},{"path":"https://optad.github.io/adoptr/reference/ContinuousPrior-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Continuous univariate prior distributions ‚Äî ContinuousPrior-class","text":"pdf vectorized univariate PDF function support numeric vector length two bounds compact interval pdf positive. order integer, integration order employed Gaussian quadrature integration rule evaluate scores. Automatically set length(n2_pivots) length(n2_pivots) == length(c2_pivots) > 1, otherwise c2 n2 taken constant stage-two replicated match number pivots specified order label object label (string) tighten_support logical indicating support tightened check_normalization logical indicating checked pdf defines density.","code":""},{"path":"https://optad.github.io/adoptr/reference/ContinuousPrior-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Continuous univariate prior distributions ‚Äî ContinuousPrior-class","text":"pdf cf. parameter 'pdf' support cf. parameter 'support' pivots normalized pivots integration rule ([-1, 1]) actual pivots scaled support prior weights weights integration rule pivots approximating integrals delta","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/ContinuousPrior-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Continuous univariate prior distributions ‚Äî ContinuousPrior-class","text":"","code":"ContinuousPrior(function(x) 2*x, c(0, 1)) #> ContinuousPrior<[0,1]>"},{"path":"https://optad.github.io/adoptr/reference/DataDistribution-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Data distributions ‚Äî DataDistribution-class","title":"Data distributions ‚Äî DataDistribution-class","text":"DataDistribution abstract class used represent distribution sufficient statistic x given sample size n single parameter value theta.","code":""},{"path":"https://optad.github.io/adoptr/reference/DataDistribution-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data distributions ‚Äî DataDistribution-class","text":"x outcome n sample size theta distribution parameter ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/DataDistribution-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data distributions ‚Äî DataDistribution-class","text":"abstraction layer allows representation t-distributions (unknown variance), normal distribution (known variance), normal approximation binary endpoint. Currently, two implemented versions Normal-class Binomial-class. logical option two_armed allows decide whether one-arm two-arm (default) design computed. case two-arm design sample sizes per group.","code":""},{"path":"https://optad.github.io/adoptr/reference/DataDistribution-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Data distributions ‚Äî DataDistribution-class","text":"two_armed Logical indicates two-arm design assumed.","code":""},{"path":"https://optad.github.io/adoptr/reference/DataDistribution-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data distributions ‚Äî DataDistribution-class","text":"","code":"normaldist   <- Normal(two_armed = FALSE) binomialdist <- Binomial(rate_control = .25, two_armed = TRUE)"},{"path":"https://optad.github.io/adoptr/reference/GroupSequentialDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Group-sequential two-stage designs ‚Äî GroupSequentialDesign-class","title":"Group-sequential two-stage designs ‚Äî GroupSequentialDesign-class","text":"Group-sequential designs sub-class TwoStageDesign class constant stage-two sample size. See TwoStageDesign slot details. group-sequential design can converted fully flexible TwoStageDesign (see examples section).","code":""},{"path":"https://optad.github.io/adoptr/reference/GroupSequentialDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group-sequential two-stage designs ‚Äî GroupSequentialDesign-class","text":"","code":"GroupSequentialDesign(n1, ...)  # S4 method for class 'numeric' GroupSequentialDesign(   n1,   c1f,   c1e,   n2_pivots,   c2_pivots,   order = NULL,   event_rate,   ... )  # S4 method for class 'GroupSequentialDesign' TwoStageDesign(n1, event_rate, ...)  # S4 method for class 'GroupSequentialDesignSurvival' TwoStageDesign(n1, ...)"},{"path":"https://optad.github.io/adoptr/reference/GroupSequentialDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group-sequential two-stage designs ‚Äî GroupSequentialDesign-class","text":"n1 stage one sample size GroupSequentialDesign object convert (overloaded TwoStageDesign) ... optional arguments c1f early futility stopping boundary c1e early efficacy stopping boundary n2_pivots numeric length one, stage-two sample size c2_pivots numeric vector, stage-two critical values integration pivot points order Gaussian quadrature rule use integration, set length(c2_pivots) NULL, otherwise first value c2_pivots repeated 'order'-times. event_rate probability subject either group eventually event, needs specified time--event endpoints.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/GroupSequentialDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group-sequential two-stage designs ‚Äî GroupSequentialDesign-class","text":"","code":"design <- GroupSequentialDesign(25, 0, 2, 25, c(1, 1.5, 2.5)) summary(design) #> GroupSequentialDesign: n1 =  25  #>            futility |      continue     | efficacy #>        x1:    -0.00 |  0.23  1.00  1.77 |  2.00 #>    c2(x1):     +Inf | +1.00 +1.50 +2.50 |  -Inf #>    n2(x1):        0 |    25    25    25 |     0 #>   design_survival <- GroupSequentialDesign(25, 0, 2, 25, c(1, 1.5, 2.5), event_rate = 0.7)  TwoStageDesign(design) #> TwoStageDesign<n1=25;0.0<=x1<=2.0:n2=25>   TwoStageDesign(design_survival) #> TwoStageDesignSurvival<n_events1=25;0.0<=x1<=2.0;n_events2=25>"},{"path":"https://optad.github.io/adoptr/reference/GroupSequentialDesignSurvival-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Group-sequential two-stage designs for time-to-event-endpoints ‚Äî GroupSequentialDesignSurvival-class","title":"Group-sequential two-stage designs for time-to-event-endpoints ‚Äî GroupSequentialDesignSurvival-class","text":"Group-sequential designs time--event-endpoints subclass TwoStageDesignSurvival GroupSequentialDesign.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/MaximumSampleSize-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum Sample Size of a Design ‚Äî MaximumSampleSize-class","title":"Maximum Sample Size of a Design ‚Äî MaximumSampleSize-class","text":"score evaluates max(n(d)) design d.","code":""},{"path":"https://optad.github.io/adoptr/reference/MaximumSampleSize-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum Sample Size of a Design ‚Äî MaximumSampleSize-class","text":"","code":"MaximumSampleSize(label = \"max(n(x1))\")  # S4 method for class 'MaximumSampleSize,TwoStageDesign' evaluate(s, design, optimization = FALSE, ...)"},{"path":"https://optad.github.io/adoptr/reference/MaximumSampleSize-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum Sample Size of a Design ‚Äî MaximumSampleSize-class","text":"label object label (string) s Score object design object optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization. ... optional arguments","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/MaximumSampleSize-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum Sample Size of a Design ‚Äî MaximumSampleSize-class","text":"","code":"design <- TwoStageDesign(50, .0, 2.0, 50, 2.0, order = 5L) mss    <- MaximumSampleSize() evaluate(mss, design) #> [1] 100"},{"path":"https://optad.github.io/adoptr/reference/N1-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Regularize n1 ‚Äî N1-class","title":"Regularize n1 ‚Äî N1-class","text":"N1 class computes n1 value design. can used score minimize.","code":""},{"path":"https://optad.github.io/adoptr/reference/N1-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regularize n1 ‚Äî N1-class","text":"","code":"N1(label = NA_character_)  # S4 method for class 'N1,TwoStageDesign' evaluate(s, design, optimization = FALSE, ...)"},{"path":"https://optad.github.io/adoptr/reference/N1-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Regularize n1 ‚Äî N1-class","text":"label object label (string) s Score object design object optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization. ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/N1-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Regularize n1 ‚Äî N1-class","text":"object class N1","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/N1-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regularize n1 ‚Äî N1-class","text":"","code":"n1_score <- N1()  evaluate(    N1(),    TwoStageDesign(70, 0, 2, rep(60, 6), rep(1.7, 6)) ) # 70 #> [1] 70"},{"path":"https://optad.github.io/adoptr/reference/NestedModels-class.html","id":null,"dir":"Reference","previous_headings":"","what":"F-Distribution ‚Äî NestedModels-class","title":"F-Distribution ‚Äî NestedModels-class","text":"Implements F-distribution used ANOVA comparison fit two nested regression models. cases, test statistic follows F-distribution. NestedModel used compare fit two regression models, one model contains independent variables smaller model subset. , one can use ANOVA determine whether variance can explained adding independent variables. class ANOVA, number independent variables smaller model set \\(1\\) order match degrees freedom obtain one-way ANOVA.","code":""},{"path":"https://optad.github.io/adoptr/reference/NestedModels-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"F-Distribution ‚Äî NestedModels-class","text":"","code":"NestedModels(p_inner, p_outer)  # S4 method for class 'NestedModels' quantile(x, probs, n, theta, ...)  # S4 method for class 'NestedModels,numeric' simulate(object, nsim, n, theta, seed = NULL, ...)"},{"path":"https://optad.github.io/adoptr/reference/NestedModels-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"F-Distribution ‚Äî NestedModels-class","text":"p_inner number independent variables smaller model p_outer number independent variables bigger model x outcome probs vector probabilities n sample size theta distribution parameter ... optional arguments object object class NestedModels nsim number simulation runs seed random seed","code":""},{"path":"https://optad.github.io/adoptr/reference/NestedModels-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"F-Distribution ‚Äî NestedModels-class","text":"p_inner number parameters smaller model p_outer number parameters bigger model","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/NestedModels-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"F-Distribution ‚Äî NestedModels-class","text":"","code":"model <- NestedModels(2, 4)"},{"path":"https://optad.github.io/adoptr/reference/NormalDataDistribution-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Normal data distribution ‚Äî Normal-class","title":"Normal data distribution ‚Äî Normal-class","text":"Implements normal data distribution z-values given observed z-value stage size. Standard deviation 1 mean Œ∏ ‚àön Œ∏ standardized effect size. option two_armed can set decide whether one-arm two-arm design computed.","code":""},{"path":"https://optad.github.io/adoptr/reference/NormalDataDistribution-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normal data distribution ‚Äî Normal-class","text":"","code":"Normal(two_armed = TRUE)  # S4 method for class 'Normal' quantile(x, probs, n, theta, ...)  # S4 method for class 'Normal,numeric' simulate(object, nsim, n, theta, seed = NULL, ...)"},{"path":"https://optad.github.io/adoptr/reference/NormalDataDistribution-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normal data distribution ‚Äî Normal-class","text":"two_armed logical indicating two-armed trial regarded x outcome probs vector probabilities n sample size theta distribution parameter ... optional arguments object object class Normal nsim number simulation runs seed random seed","code":""},{"path":"https://optad.github.io/adoptr/reference/NormalDataDistribution-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Normal data distribution ‚Äî Normal-class","text":"See DataDistribution-class details.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/NormalDataDistribution-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normal data distribution ‚Äî Normal-class","text":"","code":"datadist <- Normal(two_armed = TRUE)"},{"path":"https://optad.github.io/adoptr/reference/OneStageDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"One-stage designs ‚Äî OneStageDesign-class","title":"One-stage designs ‚Äî OneStageDesign-class","text":"OneStageDesign implements one-stage design special case two-stage design, .e. sub-class TwoStageDesign. possible defining n2 = 0, c = c1f = c1e, c2(x1) = ifelse(x1NaN).","code":""},{"path":"https://optad.github.io/adoptr/reference/OneStageDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"One-stage designs ‚Äî OneStageDesign-class","text":"","code":"OneStageDesign(n, ...)  # S4 method for class 'numeric' OneStageDesign(n, c, event_rate)  # S4 method for class 'OneStageDesign' TwoStageDesign(n1, event_rate, order = 5L, eps = 0.01, ...)  # S4 method for class 'OneStageDesignSurvival' TwoStageDesign(n1, order = 5L, eps = 0.01, ...)  # S4 method for class 'OneStageDesign' plot(x, y, ...)"},{"path":"https://optad.github.io/adoptr/reference/OneStageDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"One-stage designs ‚Äî OneStageDesign-class","text":"n sample size (stage-one sample size) ... optional arguments c rejection boundary (c = c1f = c1e) event_rate probability subject either group eventually event, needs specified time--event endpoints. n1 OneStageDesign object convert, overloaded TwoStageDesign order integer >= 2, default 5; order Gaussian quadrature integration rule use new TwoStageDesign. eps numeric > 0, default = .01; single critical value c must split continuation interval [c1f, c1e]; given c +/- eps. x design plot y used","code":""},{"path":"https://optad.github.io/adoptr/reference/OneStageDesign-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"One-stage designs ‚Äî OneStageDesign-class","text":"Note default plot,TwoStageDesign-method method supported OneStageDesign objects.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/OneStageDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"One-stage designs ‚Äî OneStageDesign-class","text":"","code":"design <- OneStageDesign(30, 1.96) summary(design) #> OneStageDesign: n1 =  30  #>            futility | continue | efficacy #>        x1:     1.96 |   NaN |  1.96 #>    c2(x1):     +Inf |    NA |  -Inf #>    n2(x1):        0 |     0 |     0 #>  design_twostage <- TwoStageDesign(design) summary(design_twostage) #> TwoStageDesign: n1 =  30  #>            futility |            continue           | efficacy #>        x1:     1.95 |  1.95  1.95  1.96  1.97  1.97 |  1.97 #>    c2(x1):     +Inf | +3.00 +3.00 +0.00 -3.00 -3.00 |  -Inf #>    n2(x1):        0 |     0     0     0     0     0 |     0 #>  design_survival <- OneStageDesign(30, 1.96, 0.7)  TwoStageDesign(design_survival) #> TwoStageDesignSurvival<n_events1=30;1.9<=x1<=2.0;n_events2=0>"},{"path":"https://optad.github.io/adoptr/reference/OneStageDesignSurvival-class.html","id":null,"dir":"Reference","previous_headings":"","what":"One-stage designs for time-to-event endpoints ‚Äî OneStageDesignSurvival-class","title":"One-stage designs for time-to-event endpoints ‚Äî OneStageDesignSurvival-class","text":"OneStageDesignSurvival subclass OneStageDesign TwoStageDesignSurvival.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/Pearson2xK-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Pearson's chi-squared test for contingency tables ‚Äî Pearson2xK-class","title":"Pearson's chi-squared test for contingency tables ‚Äî Pearson2xK-class","text":"test homogeneity rates k-armed trial binary endpoints, test statistic chi-squared distributed \\(k-1\\) degrees freedom null. alternative, statistic chi-squared distributed non-centrality parameter \\(\\lambda\\). function get_tau_Pearson2xk computes \\(\\tau\\), \\(\\lambda\\) given \\(n \\cdot \\tau\\), \\(n\\) number subjects per group. adoptr, \\(\\tau\\) used way \\(\\theta\\) case normally distributed test statistic.","code":""},{"path":"https://optad.github.io/adoptr/reference/Pearson2xK-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pearson's chi-squared test for contingency tables ‚Äî Pearson2xK-class","text":"","code":"Pearson2xK(n_groups)  get_tau_Pearson2xK(p_vector)"},{"path":"https://optad.github.io/adoptr/reference/Pearson2xK-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pearson's chi-squared test for contingency tables ‚Äî Pearson2xK-class","text":"n_groups number groups considered testing procedure p_vector vector denoting event rates per group","code":""},{"path":"https://optad.github.io/adoptr/reference/Pearson2xK-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pearson's chi-squared test for contingency tables ‚Äî Pearson2xK-class","text":"","code":"pearson <- Pearson2xK(3)   H1 <- PointMassPrior(get_tau_Pearson2xK(c(.3, .25, .4)), 1)"},{"path":"https://optad.github.io/adoptr/reference/PointMassPrior-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariate discrete point mass priors ‚Äî PointMassPrior-class","title":"Univariate discrete point mass priors ‚Äî PointMassPrior-class","text":"PointMassPrior sub-class Prior representing univariate prior discrete set points positive probability mass.","code":""},{"path":"https://optad.github.io/adoptr/reference/PointMassPrior-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Univariate discrete point mass priors ‚Äî PointMassPrior-class","text":"","code":"PointMassPrior(theta, mass, label = NA_character_)"},{"path":"https://optad.github.io/adoptr/reference/PointMassPrior-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Univariate discrete point mass priors ‚Äî PointMassPrior-class","text":"theta numeric vector pivot points positive prior mass mass numeric vector probability masses pivot points (must sum 1) label object label (string)","code":""},{"path":"https://optad.github.io/adoptr/reference/PointMassPrior-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Univariate discrete point mass priors ‚Äî PointMassPrior-class","text":"object class PointMassPrior, theta automatically sorted ascending order","code":""},{"path":"https://optad.github.io/adoptr/reference/PointMassPrior-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Univariate discrete point mass priors ‚Äî PointMassPrior-class","text":"theta cf. parameter 'theta' mass cf. parameter 'mass'","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/PointMassPrior-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Univariate discrete point mass priors ‚Äî PointMassPrior-class","text":"","code":"PointMassPrior(c(0, .5), c(.3, .7)) #> PointMass<Pr[0.00]=0.30;Pr[0.50]=0.70>"},{"path":"https://optad.github.io/adoptr/reference/Prior-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariate prior on model parameter ‚Äî Prior-class","title":"Univariate prior on model parameter ‚Äî Prior-class","text":"Prior object represents prior distribution single model parameter DataDistribution class object. Together prior data-distribution specify class joint distribution test statisic, X, parameter, theta. Currently, adoptr allows simple models single parameter. Implementations PointMassPrior ContinuousPrior available.","code":""},{"path":"https://optad.github.io/adoptr/reference/Prior-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Univariate prior on model parameter ‚Äî Prior-class","text":"example working priors, see .","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/Prior-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Univariate prior on model parameter ‚Äî Prior-class","text":"","code":"disc_prior <- PointMassPrior(c(0.1, 0.25), c(0.4, 0.6))  cont_prior <- ContinuousPrior(   pdf     = function(x) dnorm(x, mean = 0.3, sd = 0.2),   support = c(-2, 3) )"},{"path":"https://optad.github.io/adoptr/reference/Scores.html","id":null,"dir":"Reference","previous_headings":"","what":"Scores ‚Äî Scores","title":"Scores ‚Äî Scores","text":"adoptr scores used assess performance design. can done either conditionally observed stage-one outcome unconditionally. Consequently, score objects either class ConditionalScore UnconditionalScore.","code":""},{"path":"https://optad.github.io/adoptr/reference/Scores.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scores ‚Äî Scores","text":"","code":"expected(s, data_distribution, prior, ...)  # S4 method for class 'ConditionalScore' expected(s, data_distribution, prior, label = NA_character_, ...)  evaluate(s, design, ...)  # S4 method for class 'IntegralScore,TwoStageDesign' evaluate(s, design, optimization = FALSE, subdivisions = 10000L, ...)"},{"path":"https://optad.github.io/adoptr/reference/Scores.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scores ‚Äî Scores","text":"s Score object data_distribution DataDistribution object prior Prior object ... optional arguments label object label (string) design object optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization. subdivisions maximal number subdivisions evaluating integral score using adaptive quadrature (optimization = FALSE)","code":""},{"path":"https://optad.github.io/adoptr/reference/Scores.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scores ‚Äî Scores","text":"return value. Generic description class Score.","code":""},{"path":"https://optad.github.io/adoptr/reference/Scores.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Scores ‚Äî Scores","text":"scores can evaluated design using evaluate method. Note evaluate requires third argument x1 conditional scores (observed stage-one outcome). ConditionalScore can converted UnconditionalScore forming expected value using expected. returned unconditional score class IntegralScore.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/Scores.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scores ‚Äî Scores","text":"","code":"design <- TwoStageDesign(   n1    = 25,   c1f   = 0,   c1e   = 2.5,   n2    = 50,   c2    = 1.96,   order = 7L ) prior <- PointMassPrior(.3, 1)  # conditional cp <- ConditionalPower(Normal(), prior) expected(cp, Normal(), prior) #> E[Pr[x2>=c2(x1)|x1]]<Normal<two-armed>;PointMass<0.30>>  evaluate(cp, design, x1 = .5) #> [1] 0.3227581  # unconditional power <- Power(Normal(), prior) evaluate(power, design) #> [1] 0.3269562 evaluate(power, design, optimization = TRUE) # use non-adaptive quadrature #> [1] 0.3269562"},{"path":"https://optad.github.io/adoptr/reference/StudentDataDistribution-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Student's t data distribution ‚Äî Student-class","title":"Student's t data distribution ‚Äî Student-class","text":"Implements exact t-distributions instead normal approximation","code":""},{"path":"https://optad.github.io/adoptr/reference/StudentDataDistribution-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Student's t data distribution ‚Äî Student-class","text":"","code":"Student(two_armed = TRUE)  # S4 method for class 'Student' quantile(x, probs, n, theta, ...)  # S4 method for class 'Student,numeric' simulate(object, nsim, n, theta, seed = NULL, ...)"},{"path":"https://optad.github.io/adoptr/reference/StudentDataDistribution-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Student's t data distribution ‚Äî Student-class","text":"two_armed logical indicating two-armed trial regarded x outcome probs vector probabilities n sample size theta distribution parameter ... optional arguments object object class Student nsim number simulation runs seed random seed","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/StudentDataDistribution-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Student's t data distribution ‚Äî Student-class","text":"","code":"datadist <- Student(two_armed = TRUE)"},{"path":"https://optad.github.io/adoptr/reference/SurvivalDataDistribution-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-rank test ‚Äî Survival-class","title":"Log-rank test ‚Äî Survival-class","text":"Implements normal approximation log-rank test statistic.","code":""},{"path":"https://optad.github.io/adoptr/reference/SurvivalDataDistribution-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-rank test ‚Äî Survival-class","text":"","code":"Survival(event_rate, two_armed = TRUE)  # S4 method for class 'Survival' quantile(x, probs, n, theta, ...)  # S4 method for class 'Survival,numeric' simulate(object, nsim, n, theta, seed = NULL, ...)"},{"path":"https://optad.github.io/adoptr/reference/SurvivalDataDistribution-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-rank test ‚Äî Survival-class","text":"event_rate probability subject eventually event two_armed logical indicating two-armed trial regarded x outcome probs vector probabilities n sample size theta distribution parameter ... optional arguments object object class Survival nsim number simulation runs seed random seed","code":""},{"path":"https://optad.github.io/adoptr/reference/SurvivalDataDistribution-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Log-rank test ‚Äî Survival-class","text":"event_rate cf. parameter 'event_rate'","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/SurvivalDataDistribution-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log-rank test ‚Äî Survival-class","text":"","code":"datadist <- Survival(event_rate=0.6, two_armed=TRUE)"},{"path":"https://optad.github.io/adoptr/reference/SurvivalDesign.html","id":null,"dir":"Reference","previous_headings":"","what":"SurvivalDesign ‚Äî SurvivalDesign","title":"SurvivalDesign ‚Äî SurvivalDesign","text":"SurvivalDesign function converts arbitrary design survival design.","code":""},{"path":"https://optad.github.io/adoptr/reference/SurvivalDesign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SurvivalDesign ‚Äî SurvivalDesign","text":"","code":"SurvivalDesign(design, event_rate)  # S4 method for class 'TwoStageDesign' SurvivalDesign(design, event_rate)  # S4 method for class 'TwoStageDesign' TwoStageDesign(n1, event_rate)  # S4 method for class 'OneStageDesign' OneStageDesign(n, event_rate)  # S4 method for class 'OneStageDesign' SurvivalDesign(design, event_rate)  # S4 method for class 'GroupSequentialDesign' GroupSequentialDesign(n1, event_rate)  # S4 method for class 'GroupSequentialDesign' SurvivalDesign(design, event_rate)"},{"path":"https://optad.github.io/adoptr/reference/SurvivalDesign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SurvivalDesign ‚Äî SurvivalDesign","text":"design design converted survival design event_rate probability subject either group eventually event n1 design object convert (overloaded TwoStageDesign) n design object convert (overloaded TwoStageDesign)","code":""},{"path":"https://optad.github.io/adoptr/reference/SurvivalDesign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SurvivalDesign ‚Äî SurvivalDesign","text":"Converts type design survival design","code":""},{"path":"https://optad.github.io/adoptr/reference/SurvivalDesign.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SurvivalDesign ‚Äî SurvivalDesign","text":"","code":"design <- get_initial_design(0.4, 0.025, 0.1) SurvivalDesign(design, 0.8) #> TwoStageDesignSurvival<n_events1=72;0.0<=x1<=2.2;n_events2=33-182>   design_os <- get_initial_design(0.4, 0.025, 0.1, type_design = \"one-stage\") design_gs <- get_initial_design(0.4, 0.025, 0.1, type_design = \"group-sequential\")  OneStageDesign(design_os, 0.7) #> OneStageDesignSurvival<n_events=131;c=1.96>   GroupSequentialDesign(design_gs, 0.8) #> GroupSequentialDesignSurvival<n_events1=72;0.0<=x1<=2.2;n_events2=72>"},{"path":"https://optad.github.io/adoptr/reference/TwoStageDesign-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Two-stage designs ‚Äî TwoStageDesign-class","title":"Two-stage designs ‚Äî TwoStageDesign-class","text":"TwoStageDesign fundamental design class adoptr package. Formally, represent generic two-stage design five-tuple (n1, c1f, c1e, n2(¬∑), c2(¬∑)). , n1 first-stage sample size (per group), c1f c1e boundaries early stopping futility efficacy, respectively. Since trial design two-stage design, elements n2(¬∑) (stage-two sample size) c2(¬∑) (stage-two critical value) functions first-stage outcome X1=x1. X1 denotes first-stage test statistic. brief description definition two-stage designs can read . available methods, see 'See Also' section end page.","code":""},{"path":"https://optad.github.io/adoptr/reference/TwoStageDesign-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Two-stage designs ‚Äî TwoStageDesign-class","text":"","code":"TwoStageDesign(n1, ...)  # S4 method for class 'numeric' TwoStageDesign(   n1,   c1f,   c1e,   n2_pivots,   c2_pivots,   order = NULL,   event_rate,   ... )  # S4 method for class 'TwoStageDesign' summary(object, ..., rounded = TRUE)"},{"path":"https://optad.github.io/adoptr/reference/TwoStageDesign-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Two-stage designs ‚Äî TwoStageDesign-class","text":"n1 stage-one sample size ... optional arguments c1f early futility stopping boundary c1e early efficacy stopping boundary n2_pivots numeric vector, stage-two sample size integration pivot points c2_pivots numeric vector, stage-two critical values integration pivot points order integer, integration order employed Gaussian quadrature integration rule evaluate scores. Automatically set length(n2_pivots) length(n2_pivots) == length(c2_pivots) > 1, otherwise c2 n2 taken constant stage-two replicated match number pivots specified order event_rate probability subject either group eventually event, needs specified time--event endpoints object object show rounded rounded n-values used?","code":""},{"path":"https://optad.github.io/adoptr/reference/TwoStageDesign-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Two-stage designs ‚Äî TwoStageDesign-class","text":"summary can used quickly compute display basic facts TwoStageDesign. arbitrary number names UnconditionalScore objects can provided via optional arguments ... included summary displayed using print.","code":""},{"path":"https://optad.github.io/adoptr/reference/TwoStageDesign-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Two-stage designs ‚Äî TwoStageDesign-class","text":"n1 cf. parameter 'n1' c1f cf. parameter 'c1f' c1e cf. parameter 'c1e' n2_pivots vector length 'order' giving values n2 pivot points numeric integration rule c2_pivots vector length order giving values c2 pivot points numeric integration rule x1_norm_pivots normalized pivots integration rule ([-1, 1]) actual pivots scaled interval [c1f, c1e] can obtained internal method adoptr:::scaled_integration_pivots(design) weights weights integration rule x1_norm_pivots approximating integrals x1 tunable named logical vector indicating whether corresponding slot considered tunable parameter (.e. whether can changed optimization via minimize ; cf. make_fixed)","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/TwoStageDesign-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Two-stage designs ‚Äî TwoStageDesign-class","text":"","code":"design <- TwoStageDesign(50, 0, 2, 50.0, 2.0, 5) pow    <- Power(Normal(), PointMassPrior(.4, 1)) summary(design, \"Power\" = pow) #> TwoStageDesign: n1 =  50  #>            futility |            continue           | efficacy #>        x1:    -0.00 |  0.09  0.46  1.00  1.54  1.91 |  2.00 #>    c2(x1):     +Inf | +2.00 +2.00 +2.00 +2.00 +2.00 |  -Inf #>    n2(x1):        0 |    50    50    50    50    50 |     0 #>     Power:      0.739 #>"},{"path":"https://optad.github.io/adoptr/reference/TwoStageDesignSurvival-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Two-stage design for time-to-event-endpoints ‚Äî TwoStageDesignSurvival-class","title":"Two-stage design for time-to-event-endpoints ‚Äî TwoStageDesignSurvival-class","text":"conducting study time--event endpoints, main interest sample size, number overall necessary events. Thus, adoptr use sample size calculating design. Instead, uses number events directly. framework adoptr, calculations done group-wise, groups equal-sized. means, number events adoptr computed half overall number necessary events. order facilitate issue, look summary show functions changed survival analysis setting. sample size implicitly determined dividing number events event rate. Survival objects created, argument event_rate missing.","code":""},{"path":"https://optad.github.io/adoptr/reference/TwoStageDesignSurvival-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Two-stage design for time-to-event-endpoints ‚Äî TwoStageDesignSurvival-class","text":"event_rate probability subject either group eventually event","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/ZSquared-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Distribution class of a squared normal distribution ‚Äî ZSquared-class","title":"Distribution class of a squared normal distribution ‚Äî ZSquared-class","text":"Implementation \\(Z^2\\), \\(Z\\) normally distributed mean \\(\\mu\\) variance \\(\\sigma^2\\). \\(Z^2\\) chi-squared distributed \\(1\\) degree freedom non-centrality parameter \\((\\mu/\\sigma)^2\\). function get_tau_ZSquared computes factor \\(\\tau=(\\mu/\\sigma)^2\\), \\(\\tau\\) equivalent \\(\\theta\\) normally distributed case. square normal distribution \\(Z^2\\) can used two-sided hypothesis testing.","code":""},{"path":"https://optad.github.io/adoptr/reference/ZSquared-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distribution class of a squared normal distribution ‚Äî ZSquared-class","text":"","code":"ZSquared(two_armed = TRUE)  get_tau_ZSquared(mu, sigma)"},{"path":"https://optad.github.io/adoptr/reference/ZSquared-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distribution class of a squared normal distribution ‚Äî ZSquared-class","text":"two_armed logical indicating two-armed trial regarded mu mean Z sigma standard deviation Z","code":""},{"path":"https://optad.github.io/adoptr/reference/ZSquared-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distribution class of a squared normal distribution ‚Äî ZSquared-class","text":"","code":"zsquared <- ZSquared(FALSE)   H1 <- PointMassPrior(get_tau_ZSquared(0.4, 1), 1)"},{"path":"https://optad.github.io/adoptr/reference/adoptr.html","id":null,"dir":"Reference","previous_headings":"","what":"Adaptive Optimal Two-Stage Designs ‚Äî adoptr","title":"Adaptive Optimal Two-Stage Designs ‚Äî adoptr","text":"adoptr package provides functionality explore custom optimal two-stage designs one- two-arm superiority tests. details theoretical background see doi:10.1002/sim.8291 doi:10.18637/jss.v098.i09. adoptr makes heavy use S4 class system. good place start learning can found .","code":""},{"path":"https://optad.github.io/adoptr/reference/adoptr.html","id":"quickstart","dir":"Reference","previous_headings":"","what":"Quickstart","title":"Adaptive Optimal Two-Stage Designs ‚Äî adoptr","text":"sample workflow quick demo capabilities, see . detailed description background usage adoptr can found doi:10.18637/jss.v098.i09 . variety examples presented validation report hosted .","code":""},{"path":"https://optad.github.io/adoptr/reference/adoptr.html","id":"designs","dir":"Reference","previous_headings":"","what":"Designs","title":"Adaptive Optimal Two-Stage Designs ‚Äî adoptr","text":"adoptr currently supports TwoStageDesign, GroupSequentialDesign, OneStageDesign.","code":""},{"path":"https://optad.github.io/adoptr/reference/adoptr.html","id":"data-distributions","dir":"Reference","previous_headings":"","what":"Data distributions","title":"Adaptive Optimal Two-Stage Designs ‚Äî adoptr","text":"implemented data distributions Normal, Binomial, Student, Survival, ChiSquared (including Pearson2xK ZSquared) ANOVA.","code":""},{"path":"https://optad.github.io/adoptr/reference/adoptr.html","id":"priors","dir":"Reference","previous_headings":"","what":"Priors","title":"Adaptive Optimal Two-Stage Designs ‚Äî adoptr","text":"ContinuousPrior PointMassPrior supported single parameter DataDistribution.","code":""},{"path":"https://optad.github.io/adoptr/reference/adoptr.html","id":"scores","dir":"Reference","previous_headings":"","what":"Scores","title":"Adaptive Optimal Two-Stage Designs ‚Äî adoptr","text":"See Scores information basic system representing scores. Available scores ConditionalPower, ConditionalSampleSize, Power, ExpectedSampleSize.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/adoptr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Adaptive Optimal Two-Stage Designs ‚Äî adoptr","text":"Maintainer: Maximilian Pilz maximilian.pilz@itwm.fraunhofer.de (ORCID) Authors: Kevin Kunzmann kevin.kunzmann@boehringer-ingelheim.com (ORCID) [copyright holder] Jan Meis meis@imbi.uni-heidelberg.de (ORCID) Nico Bruder bruder@imbi.uni-heidelberg.de","code":""},{"path":"https://optad.github.io/adoptr/reference/boundary-designs.html","id":null,"dir":"Reference","previous_headings":"","what":"Boundary designs ‚Äî get_lower_boundary_design","title":"Boundary designs ‚Äî get_lower_boundary_design","text":"optimization method minimize based package nloptr. requires upper lower boundaries optimization. boundaries can computed via lower_boundary_design respectively upper_boundary_design. implemented default minimize. Note minimize allows user define boundary designs, .","code":""},{"path":"https://optad.github.io/adoptr/reference/boundary-designs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Boundary designs ‚Äî get_lower_boundary_design","text":"","code":"get_lower_boundary_design(initial_design, ...)  get_upper_boundary_design(initial_design, ...)  # S4 method for class 'OneStageDesign' get_lower_boundary_design(initial_design, n1 = 1, c1_buffer = 2, ...)  # S4 method for class 'GroupSequentialDesign' get_lower_boundary_design(   initial_design,   n1 = 1,   n2_pivots = 1,   c1_buffer = 2,   c2_buffer = 2,   ... )  # S4 method for class 'TwoStageDesign' get_lower_boundary_design(   initial_design,   n1 = 1,   n2_pivots = 1,   c1_buffer = 2,   c2_buffer = 2,   ... )  # S4 method for class 'OneStageDesign' get_upper_boundary_design(   initial_design,   n1 = 5 * initial_design@n1,   c1_buffer = 2,   ... )  # S4 method for class 'GroupSequentialDesign' get_upper_boundary_design(   initial_design,   n1 = 5 * initial_design@n1,   n2_pivots = 5 * initial_design@n2_pivots,   c1_buffer = 2,   c2_buffer = 2,   ... )  # S4 method for class 'TwoStageDesign' get_upper_boundary_design(   initial_design,   n1 = 5 * initial_design@n1,   n2_pivots = 5 * initial_design@n2_pivots,   c1_buffer = 2,   c2_buffer = 2,   ... )"},{"path":"https://optad.github.io/adoptr/reference/boundary-designs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Boundary designs ‚Äî get_lower_boundary_design","text":"initial_design initial design ... optional arguments values c1f c1e initial design shifted c1f - c1_buffer c1e - c1_buffer get_lower_boundary_design, respectively, c1f + c1_buffer c1e + c1_buffer get_upper_boundary_design. handled analogously c2_pivots c2_buffer. n1 bound first-stage sample size n1 c1_buffer shift early-stopping boundaries initial ones n2_pivots bound second-stage sample size n2 c2_buffer shift final decision boundary initial one","code":""},{"path":"https://optad.github.io/adoptr/reference/boundary-designs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Boundary designs ‚Äî get_lower_boundary_design","text":"object class TwoStageDesign.","code":""},{"path":"https://optad.github.io/adoptr/reference/boundary-designs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Boundary designs ‚Äî get_lower_boundary_design","text":"","code":"initial_design <- TwoStageDesign(   n1    = 25,   c1f   = 0,   c1e   = 2.5,   n2    = 50,   c2    = 1.96,   order = 7L   ) get_lower_boundary_design(initial_design) #> TwoStageDesign<n1=1;-2.0<=x1<=0.5:n2=1>"},{"path":"https://optad.github.io/adoptr/reference/bounds.html","id":null,"dir":"Reference","previous_headings":"","what":"Get support of a prior or data distribution ‚Äî bounds","title":"Get support of a prior or data distribution ‚Äî bounds","text":"bounds() returns range support prior data distribution.","code":""},{"path":"https://optad.github.io/adoptr/reference/bounds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get support of a prior or data distribution ‚Äî bounds","text":"","code":"bounds(dist, ...)  # S4 method for class 'ContinuousPrior' bounds(dist, ...)  # S4 method for class 'PointMassPrior' bounds(dist, ...)"},{"path":"https://optad.github.io/adoptr/reference/bounds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get support of a prior or data distribution ‚Äî bounds","text":"dist univariate distribution object ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/bounds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get support of a prior or data distribution ‚Äî bounds","text":"numeric length two, c(lower, upper)","code":""},{"path":"https://optad.github.io/adoptr/reference/bounds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get support of a prior or data distribution ‚Äî bounds","text":"","code":"bounds(ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4))) #> [1] 0.2 0.4 # > 0.2 0.4  bounds(PointMassPrior(c(0, .5), c(.3, .7))) #> [1] 0.0 0.5 # > 0.3 0.7"},{"path":"https://optad.github.io/adoptr/reference/composite.html","id":null,"dir":"Reference","previous_headings":"","what":"Score Composition ‚Äî composite","title":"Score Composition ‚Äî composite","text":"composite defines new composite scores point-wise evaluation scores valid numerical expression.","code":""},{"path":"https://optad.github.io/adoptr/reference/composite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Score Composition ‚Äî composite","text":"","code":"composite(expr, label = NA_character_)  # S4 method for class 'CompositeScore,TwoStageDesign' evaluate(s, design, ...)"},{"path":"https://optad.github.io/adoptr/reference/composite.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Score Composition ‚Äî composite","text":"expr Expression (curly brackets); must contain least one score variable; multiple scores used, must either conditional unconditional. Currently, non-score variables supported label object label (string) s object class CompositeScore design object ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/composite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Score Composition ‚Äî composite","text":"object class CompositeConditionalScore CompositeUnconditionalScore depending class scores used expr","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/composite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Score Composition ‚Äî composite","text":"","code":"ess   <- ExpectedSampleSize(Normal(), PointMassPrior(.4, 1)) power <- Power(Normal(), PointMassPrior(.4, 1))  # linear combination: composite({ess - 50*power}) #> E[n(x1)]  - 50 * Pr[x2>=c2(x1)]    # control flow (e.g. for and while loops) composite({   res <- 0   for (i in 1:3) {      res <- res + ess   }   res }) #> res <- 0; for (i in 1:3) { #>     res <- res + E[n(x1)]  #> }; res   # functional composition composite({log(ess)}) #> log(E[n(x1)] )  cp <- ConditionalPower(Normal(), PointMassPrior(.4, 1)) composite({3*cp}) #> 3 * Pr[x2>=c2(x1)|x1]"},{"path":"https://optad.github.io/adoptr/reference/condition.html","id":null,"dir":"Reference","previous_headings":"","what":"Condition a prior on an interval ‚Äî condition","title":"Condition a prior on an interval ‚Äî condition","text":"Restrict object class Prior sub-interval re-normalize PDF.","code":""},{"path":"https://optad.github.io/adoptr/reference/condition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Condition a prior on an interval ‚Äî condition","text":"","code":"condition(dist, interval, ...)  # S4 method for class 'ContinuousPrior,numeric' condition(dist, interval, ...)  # S4 method for class 'PointMassPrior,numeric' condition(dist, interval, ...)"},{"path":"https://optad.github.io/adoptr/reference/condition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Condition a prior on an interval ‚Äî condition","text":"dist univariate distribution object interval length-two numeric vector giving parameter interval condition ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/condition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Condition a prior on an interval ‚Äî condition","text":"conditional Prior given interval","code":""},{"path":"https://optad.github.io/adoptr/reference/condition.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Condition a prior on an interval ‚Äî condition","text":"","code":"tmp <- condition(     ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)),     c(.3, .5) ) bounds(tmp) # c(.3, .4) #> [1] 0.3 0.4  tmp <- condition(PointMassPrior(c(0, .5), c(.3, .7)), c(-1, .25)) expectation(tmp, identity) # 0 #> [1] 0"},{"path":"https://optad.github.io/adoptr/reference/critical-values.html","id":null,"dir":"Reference","previous_headings":"","what":"Query critical values of a design ‚Äî c2","title":"Query critical values of a design ‚Äî c2","text":"Methods access stage-two critical values TwoStageDesign. c2 returns stage-two critical value conditional stage-one test statistic.","code":""},{"path":"https://optad.github.io/adoptr/reference/critical-values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Query critical values of a design ‚Äî c2","text":"","code":"c2(d, x1, ...)  # S4 method for class 'TwoStageDesign,numeric' c2(d, x1, ...)  # S4 method for class 'OneStageDesign,numeric' c2(d, x1, ...)"},{"path":"https://optad.github.io/adoptr/reference/critical-values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Query critical values of a design ‚Äî c2","text":"d design x1 stage-one test statistic ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/critical-values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Query critical values of a design ‚Äî c2","text":"critical value function c2 design d position x1","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/critical-values.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Query critical values of a design ‚Äî c2","text":"","code":"design <- TwoStageDesign(   n1    = 25,   c1f   = 0,   c1e   = 2.5,   n2    = 50,   c2    = 1.96,   order = 7L )  c2(design, 2.2) # 1.96 #> [1] 1.96 c2(design, 3.0) # -Inf #> [1] -Inf c2(design, -1.0) # Inf #> [1] Inf  design <- TwoStageDesign(    n1    = 25,    c1f   = 0,    c1e   = 2.5,    n2    = 50,    c2    = 1.96,    order = 7L )  c2(design, 2.2) # 1.96 #> [1] 1.96 c2(design, 3.0) # -Inf #> [1] -Inf c2(design, -1.0) # Inf #> [1] Inf"},{"path":"https://optad.github.io/adoptr/reference/cumulative_distribution_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative distribution function ‚Äî cumulative_distribution_function","title":"Cumulative distribution function ‚Äî cumulative_distribution_function","text":"cumulative_distribution_function evaluates cumulative distribution function specific distribution dist point x.","code":""},{"path":"https://optad.github.io/adoptr/reference/cumulative_distribution_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative distribution function ‚Äî cumulative_distribution_function","text":"","code":"cumulative_distribution_function(dist, x, n, theta, ...)  # S4 method for class 'Binomial,numeric,numeric,numeric' cumulative_distribution_function(dist, x, n, theta, ...)  # S4 method for class 'ChiSquared,numeric,numeric,numeric' cumulative_distribution_function(dist, x, n, theta, ...)  # S4 method for class 'NestedModels,numeric,numeric,numeric' cumulative_distribution_function(dist, x, n, theta, ...)  # S4 method for class 'Normal,numeric,numeric,numeric' cumulative_distribution_function(dist, x, n, theta, ...)  # S4 method for class 'Student,numeric,numeric,numeric' cumulative_distribution_function(dist, x, n, theta, ...)  # S4 method for class 'Survival,numeric,numeric,numeric' cumulative_distribution_function(dist, x, n, theta, ...)"},{"path":"https://optad.github.io/adoptr/reference/cumulative_distribution_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative distribution function ‚Äî cumulative_distribution_function","text":"dist univariate distribution object x outcome n sample size theta distribution parameter ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/cumulative_distribution_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative distribution function ‚Äî cumulative_distribution_function","text":"value cumulative distribution function point x.","code":""},{"path":"https://optad.github.io/adoptr/reference/cumulative_distribution_function.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cumulative distribution function ‚Äî cumulative_distribution_function","text":"distribution Binomial, theta denotes rate difference intervention control group. , mean assumed ‚àö n  theta. distribution Normal, mean assumed ‚àö n  theta.","code":""},{"path":"https://optad.github.io/adoptr/reference/cumulative_distribution_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative distribution function ‚Äî cumulative_distribution_function","text":"","code":"cumulative_distribution_function(Binomial(.1, TRUE), 1, 50, .3) #> [1] 0.004310344  cumulative_distribution_function(Pearson2xK(3), 1, 30, get_tau_Pearson2xK(c(0.3,0.4,0.7,0.2))) #> [1] 0.001966853 cumulative_distribution_function(ZSquared(TRUE), 1, 35, get_tau_ZSquared(0.4, 1)) #> [1] 0.2466166   cumulative_distribution_function(ANOVA(3), 1, 30, get_tau_ANOVA(c(0.3, 0.4, 0.7, 0.2))) #> [1] 0.2402678  cumulative_distribution_function(Normal(), 1, 50, .3) #> [1] 0.3085375  cumulative_distribution_function(Student(two_armed = FALSE), .75, 50, .9) #> [1] 1.062003e-08  cumulative_distribution_function(Survival(0.6,TRUE),0.75,50,0.9) #> [1] 0.899164"},{"path":"https://optad.github.io/adoptr/reference/expectation.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected value of a function ‚Äî expectation","title":"Expected value of a function ‚Äî expectation","text":"Computes expected value vectorized, univariate function f respect distribution dist. .e., E[f(X)].","code":""},{"path":"https://optad.github.io/adoptr/reference/expectation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected value of a function ‚Äî expectation","text":"","code":"expectation(dist, f, ...)  # S4 method for class 'ContinuousPrior,function' expectation(dist, f, ...)  # S4 method for class 'PointMassPrior,function' expectation(dist, f, ...)"},{"path":"https://optad.github.io/adoptr/reference/expectation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected value of a function ‚Äî expectation","text":"dist univariate distribution object f univariate function, must vectorized ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/expectation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected value of a function ‚Äî expectation","text":"numeric, expected value f respect dist","code":""},{"path":"https://optad.github.io/adoptr/reference/expectation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expected value of a function ‚Äî expectation","text":"","code":"expectation(     ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)),     identity ) #> [1] 0.3 # > 0.3  expectation(PointMassPrior(c(0, .5), c(.3, .7)), identity) #> [1] 0.35 # > .35"},{"path":"https://optad.github.io/adoptr/reference/get_initial_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Initial design ‚Äî get_initial_design","title":"Initial design ‚Äî get_initial_design","text":"optimization method minimize requires initial design optimization. function provides variety possibilities hand-craft designs fulfill type error type II error constraints may used initial designs.","code":""},{"path":"https://optad.github.io/adoptr/reference/get_initial_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initial design ‚Äî get_initial_design","text":"","code":"get_initial_design(   theta,   alpha,   beta,   type_design = c(\"two-stage\", \"group-sequential\", \"one-stage\"),   type_c2 = c(\"linear_decreasing\", \"constant\"),   type_n2 = c(\"optimal\", \"constant\", \"linear_decreasing\", \"linear_increasing\"),   dist = Normal(),   cf,   ce,   info_ratio = 0.5,   slope,   weight = sqrt(info_ratio),   order = 7L,   ... )"},{"path":"https://optad.github.io/adoptr/reference/get_initial_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initial design ‚Äî get_initial_design","text":"theta alternative effect size normal case, rate difference alternative binomial case alpha maximal type error rate beta maximal type II error rate type_design type design type_c2 either linear-decreasing c2-function according inverse normal combination test constant c2 type_n2 design n2-function dist distribution test statistic cf first-stage futility boundary ce first-stage efficacy boundary. Note specifying boundary implies type error constraint might fulfilled anymore info_ratio ratio first second stage sample size slope slope n2 function weight weight first stage test statistics inverse normal combination test order desired integration order ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/get_initial_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initial design ‚Äî get_initial_design","text":"object class TwoStageDesign.","code":""},{"path":"https://optad.github.io/adoptr/reference/get_initial_design.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Initial design ‚Äî get_initial_design","text":"distribution test statistic specified dist. default assumes two-armed z-test. first stage efficacy boundary \\(c2\\) boundary chosen Pocock-boundaries, either \\(c_e=c_2\\) \\(c_2\\) constant \\(c_e=c\\), null hypothesis rejected \\(w_1 Z_1+w_2 Z_2>c\\). specifying \\(ce\\), clear boundaries Pocock-boundaries anymore, type error constraint may fulfilled. IMPORTANT: using t-distribution ANOVA, design probably keep type type II error, approximate designs returned.","code":""},{"path":"https://optad.github.io/adoptr/reference/get_initial_design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Initial design ‚Äî get_initial_design","text":"","code":"init <- get_initial_design(    theta = 0.3,    alpha = 0.025,    beta  = 0.2,    type_design=\"two-stage\",    type_c2=\"linear_decreasing\",    type_n2=\"linear_increasing\",    dist=Normal(),    cf=0.7,    info_ratio=0.5,    slope=23,    weight = 1/sqrt(3) )"},{"path":"https://optad.github.io/adoptr/reference/make_tunable.html","id":null,"dir":"Reference","previous_headings":"","what":"Fix parameters during optimization ‚Äî make_tunable","title":"Fix parameters during optimization ‚Äî make_tunable","text":"methods make_fixed make_tunable can used modify 'tunability' status parameters TwoStageDesign object. Tunable parameters optimized , non-tunable ('fixed') parameters considered given altered optimization.","code":""},{"path":"https://optad.github.io/adoptr/reference/make_tunable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fix parameters during optimization ‚Äî make_tunable","text":"","code":"make_tunable(x, ...)  # S4 method for class 'TwoStageDesign' make_tunable(x, ...)  make_fixed(x, ...)  # S4 method for class 'TwoStageDesign' make_fixed(x, ...)"},{"path":"https://optad.github.io/adoptr/reference/make_tunable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fix parameters during optimization ‚Äî make_tunable","text":"x TwoStageDesign object ... unquoted names slots tunability status changed.","code":""},{"path":"https://optad.github.io/adoptr/reference/make_tunable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fix parameters during optimization ‚Äî make_tunable","text":"updated object class TwoStageDesign","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/make_tunable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fix parameters during optimization ‚Äî make_tunable","text":"","code":"design <- TwoStageDesign(25, 0, 2, 25, 2, order = 5) # default: all parameters are tunable (except integration pivots, # weights and tunability status itself) design@tunable #>             n1            c1f            c1e      n2_pivots      c2_pivots  #>           TRUE           TRUE           TRUE           TRUE           TRUE  #> x1_norm_pivots        weights        tunable  #>          FALSE          FALSE          FALSE   # make n1 and the pivots of n2 fixed (not changed during optimization) design <- make_fixed(design, n1, n2_pivots) design@tunable #>             n1            c1f            c1e      n2_pivots      c2_pivots  #>          FALSE           TRUE           TRUE          FALSE           TRUE  #> x1_norm_pivots        weights        tunable  #>          FALSE          FALSE          FALSE   # make them tunable again design <- make_tunable(design, n1, n2_pivots) design@tunable #>             n1            c1f            c1e      n2_pivots      c2_pivots  #>           TRUE           TRUE           TRUE           TRUE           TRUE  #> x1_norm_pivots        weights        tunable  #>          FALSE          FALSE          FALSE"},{"path":"https://optad.github.io/adoptr/reference/minimize.html","id":null,"dir":"Reference","previous_headings":"","what":"Find optimal two-stage design by constraint minimization ‚Äî minimize","title":"Find optimal two-stage design by constraint minimization ‚Äî minimize","text":"minimize takes unconditional score constraint set (constraint) solves corresponding minimization problem using nloptr (using COBYLA default). initial design defined. also possible define lower- upper-boundary designs. done, boundaries determined automatically heuristically.","code":""},{"path":"https://optad.github.io/adoptr/reference/minimize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find optimal two-stage design by constraint minimization ‚Äî minimize","text":"","code":"minimize(   objective,   subject_to,   initial_design,   lower_boundary_design = get_lower_boundary_design(initial_design),   upper_boundary_design = get_upper_boundary_design(initial_design),   c2_decreasing = FALSE,   check_constraints = TRUE,   opts = list(algorithm = \"NLOPT_LN_COBYLA\", xtol_rel = 1e-05, maxeval = 10000),   ... )"},{"path":"https://optad.github.io/adoptr/reference/minimize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find optimal two-stage design by constraint minimization ‚Äî minimize","text":"objective objective function subject_to constraint collection initial_design initial guess (x0 nloptr) lower_boundary_design design specifying lower boundary. upper_boundary_design design specifying upper boundary c2_decreasing TRUE, c2_pivots forced monotonically decreasing check_constraints TRUE, checked constrains fulfilled opts options list passed nloptr ... optional arguments passed nloptr","code":""},{"path":"https://optad.github.io/adoptr/reference/minimize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find optimal two-stage design by constraint minimization ‚Äî minimize","text":"list elements: design resulting optimal design nloptr_return Output corresponding nloptr call call_args arguments given optimization call","code":""},{"path":"https://optad.github.io/adoptr/reference/minimize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find optimal two-stage design by constraint minimization ‚Äî minimize","text":"","code":"# Define Type one error rate toer <- Power(Normal(), PointMassPrior(0.0, 1))  # Define Power at delta = 0.4 pow <- Power(Normal(), PointMassPrior(0.4, 1))  # Define expected sample size at delta = 0.4 ess <- ExpectedSampleSize(Normal(), PointMassPrior(0.4, 1))  # Compute design minimizing ess subject to power and toer constraints # \\donttest{ minimize(     ess,     subject_to(       toer <= 0.025,       pow  >= 0.9    ),     initial_design = TwoStageDesign(50, .0, 2.0, 60.0, 2.0, 5L)  ) #> $design #> TwoStageDesign<n1=68;0.3<=x1<=2.3:n2=26-131>  #>  #> $nloptr_return #>  #> Call: #> nloptr::nloptr(x0 = tunable_parameters(initial_design), eval_f = f_obj,  #>     lb = tunable_parameters(lower_boundary_design), ub = tunable_parameters(upper_boundary_design),  #>     eval_g_ineq = g_cnstr, opts = opts) #>  #>  #> Minimization using NLopt version 2.7.1  #>  #> NLopt solver status: 4 ( NLOPT_XTOL_REACHED: Optimization stopped because  #> xtol_rel or xtol_abs (above) was reached. ) #>  #> Number of Iterations....: 3990  #> Termination conditions:  xtol_rel: 1e-05\tmaxeval: 10000  #> Number of inequality constraints:  3  #> Number of equality constraints:    0  #> Optimal value of objective function:  99.2099508305843  #> Optimal value of controls: 67.77852 0.2812201 2.26569 126.9927 111.6292 86.5138 57.48934 32.48944 2.668702  #> 2.35649 1.822003 1.113608 0.3340881 #>  #>  #>  #> $call_args #> $call_args$objective #> E[n(x1)]  #>  #> $call_args$subject_to #> An object of class \"ConstraintsCollection\" #> Slot \"unconditional_constraints\": #> [[1]] #> Pr[x2>=c2(x1)] <= 0.025  #>  #> [[2]] #> -Pr[x2>=c2(x1)]  <= -0.9  #>  #>  #> Slot \"conditional_constraints\": #> list() #>  #>  #> $call_args$initial_design #> TwoStageDesign<n1=50;0.0<=x1<=2.0:n2=60>  #>  #> $call_args$lower_boundary_design #> TwoStageDesign<n1=1;-2.0<=x1<=0.0:n2=1>  #>  #> $call_args$upper_boundary_design #> TwoStageDesign<n1=250;2.0<=x1<=4.0:n2=300>  #>  #> $call_args$c2_decreasing #> [1] FALSE #>  #> $call_args$check_constraints #> [1] TRUE #>  #> $call_args$opts #> $call_args$opts$algorithm #> [1] \"NLOPT_LN_COBYLA\" #>  #> $call_args$opts$xtol_rel #> [1] 1e-05 #>  #> $call_args$opts$maxeval #> [1] 10000 #>  #>  #>  #> attr(,\"class\") #> [1] \"adoptrOptimizationResult\" \"list\"                     # }"},{"path":"https://optad.github.io/adoptr/reference/n.html","id":null,"dir":"Reference","previous_headings":"","what":"Query sample size of a design ‚Äî n1","title":"Query sample size of a design ‚Äî n1","text":"Methods access stage-one, stage-two, overall sample size TwoStageDesign. n1 returns first-stage sample size design, n2 stage-two sample size conditional stage-one test statistic n overall sample size n1 + n2. Internally, objects class TwoStageDesign allow non-natural, real sample sizes allow smooth optimization (cf. minimize details). optional argument round allows switch internal real representation rounded version (rounding next positive integer).","code":""},{"path":"https://optad.github.io/adoptr/reference/n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Query sample size of a design ‚Äî n1","text":"","code":"n1(d, ...)  # S4 method for class 'TwoStageDesign' n1(d, round = TRUE, ...)  n2(d, x1, ...)  # S4 method for class 'TwoStageDesign,numeric' n2(d, x1, round = TRUE, ...)  n(d, x1, ...)  # S4 method for class 'TwoStageDesign,numeric' n(d, x1, round = TRUE, ...)  # S4 method for class 'OneStageDesign,numeric' n2(d, x1, ...)  # S4 method for class 'GroupSequentialDesign,numeric' n2(d, x1, round = TRUE, ...)"},{"path":"https://optad.github.io/adoptr/reference/n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Query sample size of a design ‚Äî n1","text":"d design ... optional arguments round logical sample sizes rounded next integer? x1 stage-one test statistic","code":""},{"path":"https://optad.github.io/adoptr/reference/n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Query sample size of a design ‚Äî n1","text":"sample size value design d point x1","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Query sample size of a design ‚Äî n1","text":"","code":"design <- TwoStageDesign(    n1    = 25,    c1f   = 0,    c1e   = 2.5,    n2    = 50,    c2    = 1.96,    order = 7L )  n1(design) # 25 #> [1] 25 design@n1 # 25 #> [1] 25  n(design, x1 = 2.2) # 75 #> [1] 75"},{"path":"https://optad.github.io/adoptr/reference/plot-TwoStageDesign-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot TwoStageDesign with optional set of conditional scores ‚Äî plot,TwoStageDesign-method","title":"Plot TwoStageDesign with optional set of conditional scores ‚Äî plot,TwoStageDesign-method","text":"method allows plot stage-two sample size decision boundary functions chosen design.","code":""},{"path":"https://optad.github.io/adoptr/reference/plot-TwoStageDesign-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot TwoStageDesign with optional set of conditional scores ‚Äî plot,TwoStageDesign-method","text":"","code":"# S4 method for class 'TwoStageDesign' plot(x, y = NULL, ..., rounded = TRUE, k = 100)"},{"path":"https://optad.github.io/adoptr/reference/plot-TwoStageDesign-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot TwoStageDesign with optional set of conditional scores ‚Äî plot,TwoStageDesign-method","text":"x design plot y used ... named ConditinonalScores plot design /graphic parameters rounded n-values rounded? k number points use plotting","code":""},{"path":"https://optad.github.io/adoptr/reference/plot-TwoStageDesign-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot TwoStageDesign with optional set of conditional scores ‚Äî plot,TwoStageDesign-method","text":"plot two-stage design","code":""},{"path":"https://optad.github.io/adoptr/reference/plot-TwoStageDesign-method.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot TwoStageDesign with optional set of conditional scores ‚Äî plot,TwoStageDesign-method","text":"TwoStageDesign user-defined elements class ConditionalScore.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/plot-TwoStageDesign-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot TwoStageDesign with optional set of conditional scores ‚Äî plot,TwoStageDesign-method","text":"","code":"design <- TwoStageDesign(50, 0, 2, 50, 2, 5) cp     <- ConditionalPower(dist = Normal(), prior = PointMassPrior(.4, 1)) plot(design, \"Conditional Power\" = cp, cex.axis = 2)"},{"path":"https://optad.github.io/adoptr/reference/posterior.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute posterior distribution ‚Äî posterior","title":"Compute posterior distribution ‚Äî posterior","text":"Return posterior distribution given observing stage-one outcome.","code":""},{"path":"https://optad.github.io/adoptr/reference/posterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute posterior distribution ‚Äî posterior","text":"","code":"posterior(dist, prior, x1, n1, ...)  # S4 method for class 'DataDistribution,ContinuousPrior,numeric' posterior(dist, prior, x1, n1, ...)  # S4 method for class 'DataDistribution,PointMassPrior,numeric' posterior(dist, prior, x1, n1, ...)"},{"path":"https://optad.github.io/adoptr/reference/posterior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute posterior distribution ‚Äî posterior","text":"dist univariate distribution object prior Prior object x1 stage-one test statistic n1 stage-one sample size ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/posterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute posterior distribution ‚Äî posterior","text":"Object class Prior","code":""},{"path":"https://optad.github.io/adoptr/reference/posterior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute posterior distribution ‚Äî posterior","text":"","code":"tmp <- ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)) posterior(Normal(), tmp, 2, 20) #> ContinuousPrior<[0.2,0.4]>   posterior(Normal(), PointMassPrior(0, 1), 2, 20) #> PointMass<0.00>"},{"path":"https://optad.github.io/adoptr/reference/predictive_cdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictive CDF ‚Äî predictive_cdf","title":"Predictive CDF ‚Äî predictive_cdf","text":"predictive_cdf() evaluates predictive CDF model specified DataDistribution dist Prior given stage-one outcome.","code":""},{"path":"https://optad.github.io/adoptr/reference/predictive_cdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictive CDF ‚Äî predictive_cdf","text":"","code":"predictive_cdf(dist, prior, x1, n1, ...)  # S4 method for class 'DataDistribution,ContinuousPrior,numeric' predictive_cdf(   dist,   prior,   x1,   n1,   k = 10 * (prior@support[2] - prior@support[1]) + 1,   ... )  # S4 method for class 'DataDistribution,PointMassPrior,numeric' predictive_cdf(dist, prior, x1, n1, ...)"},{"path":"https://optad.github.io/adoptr/reference/predictive_cdf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictive CDF ‚Äî predictive_cdf","text":"dist univariate distribution object prior Prior object x1 stage-one test statistic n1 stage-one sample size ... optional arguments k number pivots crude integral approximation","code":""},{"path":"https://optad.github.io/adoptr/reference/predictive_cdf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predictive CDF ‚Äî predictive_cdf","text":"numeric, value predictive CDF","code":""},{"path":"https://optad.github.io/adoptr/reference/predictive_cdf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictive CDF ‚Äî predictive_cdf","text":"","code":"tmp <- ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)) predictive_cdf(Normal(), tmp, 2, 20) #> [1] 0.8455245  predictive_cdf(Normal(), PointMassPrior(.0, 1), 0, 20) # .5 #> [1] 0.5"},{"path":"https://optad.github.io/adoptr/reference/predictive_pdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictive PDF ‚Äî predictive_pdf","title":"Predictive PDF ‚Äî predictive_pdf","text":"predictive_pdf() evaluates predictive PDF model specified DataDistribution dist Prior given stage-one outcome.","code":""},{"path":"https://optad.github.io/adoptr/reference/predictive_pdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictive PDF ‚Äî predictive_pdf","text":"","code":"predictive_pdf(dist, prior, x1, n1, ...)  # S4 method for class 'DataDistribution,ContinuousPrior,numeric' predictive_pdf(   dist,   prior,   x1,   n1,   k = 10 * (prior@support[2] - prior@support[1]) + 1,   ... )  # S4 method for class 'DataDistribution,PointMassPrior,numeric' predictive_pdf(dist, prior, x1, n1, ...)"},{"path":"https://optad.github.io/adoptr/reference/predictive_pdf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictive PDF ‚Äî predictive_pdf","text":"dist univariate distribution object prior Prior object x1 stage-one test statistic n1 stage-one sample size ... optional arguments k number pivots crude integral approximation","code":""},{"path":"https://optad.github.io/adoptr/reference/predictive_pdf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predictive PDF ‚Äî predictive_pdf","text":"numeric, value predictive PDF","code":""},{"path":"https://optad.github.io/adoptr/reference/predictive_pdf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictive PDF ‚Äî predictive_pdf","text":"","code":"tmp <- ContinuousPrior(function(x) dunif(x, .2, .4), c(.2, .4)) predictive_pdf(Normal(), tmp, 2, 20) #> [1] 0.2302199  predictive_pdf(Normal(), PointMassPrior(.3, 1), 1.5, 20) # ~.343 #> [1] 0.3426953"},{"path":"https://optad.github.io/adoptr/reference/print.adoptrOptimizationResult.html","id":null,"dir":"Reference","previous_headings":"","what":"Printing an optimization result ‚Äî print.adoptrOptimizationResult","title":"Printing an optimization result ‚Äî print.adoptrOptimizationResult","text":"Printing optimization result","code":""},{"path":"https://optad.github.io/adoptr/reference/print.adoptrOptimizationResult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Printing an optimization result ‚Äî print.adoptrOptimizationResult","text":"","code":"print(x, ...)"},{"path":"https://optad.github.io/adoptr/reference/print.adoptrOptimizationResult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Printing an optimization result ‚Äî print.adoptrOptimizationResult","text":"x object print ... arguments passed form methods","code":""},{"path":"https://optad.github.io/adoptr/reference/probability_density_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Probability density function ‚Äî probability_density_function","title":"Probability density function ‚Äî probability_density_function","text":"probability_density_function evaluates probability density function specific distribution dist point x.","code":""},{"path":"https://optad.github.io/adoptr/reference/probability_density_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probability density function ‚Äî probability_density_function","text":"","code":"probability_density_function(dist, x, n, theta, ...)  # S4 method for class 'Binomial,numeric,numeric,numeric' probability_density_function(dist, x, n, theta, ...)  # S4 method for class 'ChiSquared,numeric,numeric,numeric' probability_density_function(dist, x, n, theta, ...)  # S4 method for class 'NestedModels,numeric,numeric,numeric' probability_density_function(dist, x, n, theta, ...)  # S4 method for class 'Normal,numeric,numeric,numeric' probability_density_function(dist, x, n, theta, ...)  # S4 method for class 'Student,numeric,numeric,numeric' probability_density_function(dist, x, n, theta, ...)  # S4 method for class 'Survival,numeric,numeric,numeric' probability_density_function(dist, x, n, theta, ...)"},{"path":"https://optad.github.io/adoptr/reference/probability_density_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Probability density function ‚Äî probability_density_function","text":"dist univariate distribution object x outcome n sample size theta distribution parameter ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/probability_density_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Probability density function ‚Äî probability_density_function","text":"value probability density function point x.","code":""},{"path":"https://optad.github.io/adoptr/reference/probability_density_function.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Probability density function ‚Äî probability_density_function","text":"distribution Binomial, theta denotes rate difference intervention control group. , mean assumed ‚àö n  theta. distribution Normal, mean assumed ‚àö n  theta.","code":""},{"path":"https://optad.github.io/adoptr/reference/probability_density_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Probability density function ‚Äî probability_density_function","text":"","code":"probability_density_function(Binomial(.2, FALSE), 1, 50, .3) #> [1] 0.0008519612  probability_density_function(Pearson2xK(3), 1, 30, get_tau_Pearson2xK(c(0.3, 0.4, 0.7, 0.2))) #> [1] 0.003505548 probability_density_function(ZSquared(TRUE), 1, 35, get_tau_ZSquared(0.4, 1)) #> [1] 0.1646112   probability_density_function(ANOVA(3), 1, 30, get_tau_ANOVA(c(0.3, 0.4, 0.7, 0.2))) #> [1] 0.2513264  probability_density_function(Normal(), 1, 50, .3) #> [1] 0.3520653  probability_density_function(Student(TRUE), 1, 40, 1.1) #> [1] 0.0001946335  probability_density_function(Survival(0.6,TRUE),0.75,50,0.9) #> [1] 0.1765677"},{"path":"https://optad.github.io/adoptr/reference/simulate-TwoStageDesign-numeric-method.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw samples from a two-stage design ‚Äî simulate,TwoStageDesign,numeric-method","title":"Draw samples from a two-stage design ‚Äî simulate,TwoStageDesign,numeric-method","text":"simulate allows draw samples given TwoStageDesign.","code":""},{"path":"https://optad.github.io/adoptr/reference/simulate-TwoStageDesign-numeric-method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw samples from a two-stage design ‚Äî simulate,TwoStageDesign,numeric-method","text":"","code":"# S4 method for class 'TwoStageDesign,numeric' simulate(object, nsim, dist, theta, seed = NULL, ...)"},{"path":"https://optad.github.io/adoptr/reference/simulate-TwoStageDesign-numeric-method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw samples from a two-stage design ‚Äî simulate,TwoStageDesign,numeric-method","text":"object TwoStageDesign draw samples nsim number simulation runs dist data distribution theta location parameter data distribution seed random seed ... optional arguments","code":""},{"path":"https://optad.github.io/adoptr/reference/simulate-TwoStageDesign-numeric-method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw samples from a two-stage design ‚Äî simulate,TwoStageDesign,numeric-method","text":"simulate() returns data.frame nsim rows row (simulation run) following columns theta: effect size n1: First-stage sample size c1f: Stopping futility boundary c1e: Stopping efficacy boundary x1: First-stage outcome n2: Resulting second-stage sample size observing x1 c2: Resulting second-stage decision-boundary observing x1 x2: Second-stage outcome reject: Decision whether null hypothesis rejected ","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/simulate-TwoStageDesign-numeric-method.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw samples from a two-stage design ‚Äî simulate,TwoStageDesign,numeric-method","text":"","code":"design <- TwoStageDesign(25, 0, 2, 25, 2, order = 5) # draw samples assuming two-armed design simulate(design, 10, Normal(), .3, 42) #>    theta n1 c1f c1e        x1 n2   c2         x2 reject #> 1    0.3 25   0   2 2.4316186  0 -Inf  1.3048697   TRUE #> 2    0.3 25   0   2 0.4959620 25    2  3.3473056   TRUE #> 3    0.3 25   0   2 1.4237886 25    2 -0.3282005  FALSE #> 4    0.3 25   0   2 1.6935228 25    2  0.7818714  FALSE #> 5    0.3 25   0   2 1.4649285 25    2  0.9273388  FALSE #> 6    0.3 25   0   2 0.9545357 25    2  1.6966106  FALSE #> 7    0.3 25   0   2 2.5721822  0 -Inf -0.2842529   TRUE #> 8    0.3 25   0   2 0.9660011 25    2 -1.5957952  FALSE #> 9    0.3 25   0   2 3.0790839  0 -Inf -2.4404669   TRUE #> 10   0.3 25   0   2 0.9979461 25    2  2.3807735   TRUE"},{"path":"https://optad.github.io/adoptr/reference/subject_to.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a collection of constraints ‚Äî subject_to","title":"Create a collection of constraints ‚Äî subject_to","text":"subject_to(...) can used generate object class ConstraintsCollection arbitrary number (un)conditional constraints.","code":""},{"path":"https://optad.github.io/adoptr/reference/subject_to.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a collection of constraints ‚Äî subject_to","text":"","code":"subject_to(...)  # S4 method for class 'ConstraintsCollection,TwoStageDesign' evaluate(s, design, optimization = FALSE, ...)"},{"path":"https://optad.github.io/adoptr/reference/subject_to.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a collection of constraints ‚Äî subject_to","text":"... either constraint objects (subject_to optional arguments passed evaluate) s object class ConstraintCollection design object optimization logical, TRUE uses relaxation real parameters underlying design; used smooth optimization.","code":""},{"path":"https://optad.github.io/adoptr/reference/subject_to.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a collection of constraints ‚Äî subject_to","text":"object class ConstraintsCollection","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/subject_to.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a collection of constraints ‚Äî subject_to","text":"","code":"# define type one error rate and power toer  <- Power(Normal(), PointMassPrior(0.0, 1)) power <- Power(Normal(), PointMassPrior(0.4, 1))  # create constrain collection subject_to(   toer  <= 0.025,   power >= 0.9 ) #> An object of class \"ConstraintsCollection\" #> Slot \"unconditional_constraints\": #> [[1]] #> Pr[x2>=c2(x1)] <= 0.025  #>  #> [[2]] #> -Pr[x2>=c2(x1)]  <= -0.9  #>  #>  #> Slot \"conditional_constraints\": #> list() #>"},{"path":"https://optad.github.io/adoptr/reference/tunable_parameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Switch between numeric and S4 class representation of a design ‚Äî tunable_parameters","title":"Switch between numeric and S4 class representation of a design ‚Äî tunable_parameters","text":"Get tunable parameters design numeric vector via tunable_parameters update design object suitable vector values tunable parameters.","code":""},{"path":"https://optad.github.io/adoptr/reference/tunable_parameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Switch between numeric and S4 class representation of a design ‚Äî tunable_parameters","text":"","code":"tunable_parameters(object, ...)  # S4 method for class 'TwoStageDesign' tunable_parameters(object, ...)  # S4 method for class 'TwoStageDesign' update(object, params, ...)  # S4 method for class 'OneStageDesign' update(object, params, ...)"},{"path":"https://optad.github.io/adoptr/reference/tunable_parameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Switch between numeric and S4 class representation of a design ‚Äî tunable_parameters","text":"object TwoStageDesign object update ... optional arguments params vector design parameters, must order returned tunable_parameters","code":""},{"path":"https://optad.github.io/adoptr/reference/tunable_parameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Switch between numeric and S4 class representation of a design ‚Äî tunable_parameters","text":"tunable_parameters returns numerical values tunable parameters vector. update returns updated design.","code":""},{"path":"https://optad.github.io/adoptr/reference/tunable_parameters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Switch between numeric and S4 class representation of a design ‚Äî tunable_parameters","text":"tunable slot TwoStageDesign stores information set design parameters considered fixed (changed optimization) tunable (changed optimization). details fix certain parameters make tunable , see make_fixed make_tunable.","code":""},{"path":[]},{"path":"https://optad.github.io/adoptr/reference/tunable_parameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Switch between numeric and S4 class representation of a design ‚Äî tunable_parameters","text":"","code":"design  <- TwoStageDesign(25, 0, 2, 25, 2, order = 5) tunable_parameters(design) #>  [1] 25  0  2 25 25 25 25 25  2  2  2  2  2 design2 <- update(design, tunable_parameters(design) + 1) tunable_parameters(design2) #>  [1] 26  1  3 26 26 26 26 26  3  3  3  3  3"},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-111","dir":"Changelog","previous_headings":"","what":"adoptr 1.1.1","title":"adoptr 1.1.1","text":"fix issue new glue update","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-110","dir":"Changelog","previous_headings":"","what":"adoptr 1.1.0","title":"adoptr 1.1.0","text":"CRAN release: 2024-08-19 include survival endpoints add F-distribution chi-squared distribution check constraints fulfilled update get_initial_design vignettes binomial time--event endpoints","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-101","dir":"Changelog","previous_headings":"","what":"adoptr 1.0.1","title":"adoptr 1.0.1","text":"CRAN release: 2024-06-07 updated maintainer updated roxygen version fulfill current CRAN requirements","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-100","dir":"Changelog","previous_headings":"","what":"adoptr 1.0.0","title":"adoptr 1.0.0","text":"CRAN release: 2021-06-28 added references article journal statistical software","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-043","dir":"Changelog","previous_headings":"","what":"adoptr 0.4.3","title":"adoptr 0.4.3","text":"corrected class diagram vignette","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-042","dir":"Changelog","previous_headings":"","what":"adoptr 0.4.2","title":"adoptr 0.4.2","text":"CRAN release: 2021-05-28 minor bug/print fixes Student-t data distribution switched GitHub Actions CI/CD","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-040","dir":"Changelog","previous_headings":"","what":"adoptr 0.4.0","title":"adoptr 0.4.0","text":"included JSS article vignette","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-032","dir":"Changelog","previous_headings":"","what":"adoptr 0.3.2","title":"adoptr 0.3.2","text":"CRAN release: 2020-01-09 bugfix binomial pdf/cdf","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-031","dir":"Changelog","previous_headings":"","what":"adoptr 0.3.1","title":"adoptr 0.3.1","text":"added support binomial endpoint initial design creation convenient extended summary() function two stage designs","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-030","dir":"Changelog","previous_headings":"","what":"adoptr 0.3.0","title":"adoptr 0.3.0","text":"CRAN release: 2019-11-25 bugfix pretty printing optimization results streamlined code internal evaluation integral scores optimization; substantial speedup!","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-023","dir":"Changelog","previous_headings":"","what":"adoptr 0.2.3","title":"adoptr 0.2.3","text":"CRAN release: 2019-09-10 reworked class printing system informative minimize() now also returns S3 class object allow pretty-printing","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-022","dir":"Changelog","previous_headings":"","what":"adoptr 0.2.2","title":"adoptr 0.2.2","text":"CRAN release: 2019-07-02 fixed references SIM paper","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-021","dir":"Changelog","previous_headings":"","what":"adoptr 0.2.1","title":"adoptr 0.2.1","text":"added references SIM paper relevant places","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-020","dir":"Changelog","previous_headings":"","what":"adoptr 0.2.0","title":"adoptr 0.2.0","text":"CRAN release: 2019-06-04 new feature: composite scores allows generic expressions just affine score combinations, cf.¬†composite() affine scores (s1 + 2*s2) longer supported, use composite instead consistent class system: conditional scores longer need specification distributions default (need conditional sampel size e.g.). Instead, expected() now requires explicit specification data prior distribution integrate . Vignettes updated fixed broked tests due updated rpact","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-011","dir":"Changelog","previous_headings":"","what":"adoptr 0.1.1","title":"adoptr 0.1.1","text":"CRAN release: 2019-04-01 extended Description field DESCRIPTION full paragraph provided examples user facing functions revision docs","code":""},{"path":"https://optad.github.io/adoptr/news/index.html","id":"adoptr-010","dir":"Changelog","previous_headings":"","what":"adoptr 0.1.0","title":"adoptr 0.1.0","text":"initial release","code":""}]
