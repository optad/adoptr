<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Designs for non-normal Endpoints with approximately normal test statistics • adoptr</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Designs for non-normal Endpoints with approximately normal test statistics">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">adoptr</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.1.1.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../index.html"><span class="fa fa-home fa-lg"></span></a></li>
<li class="nav-item"><a class="nav-link" href="../articles/adoptr.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../articles/adoptr_jss.html">Overview Paper</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/working-with-priors.html">Working with Priors</a></li>
    <li><a class="dropdown-item" href="../articles/conditional-scores.html">Conditional Scores</a></li>
    <li><a class="dropdown-item" href="../articles/composite-scores.html">Composite Scores</a></li>
    <li><a class="dropdown-item" href="../articles/defining-new-scores.html">Definining New Scores</a></li>
    <li><a class="dropdown-item" href="../articles/other-endpoints.html">Non-normal Endpoints</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/optad/adoptr"><span class="fa fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Designs for non-normal Endpoints with approximately normal test statistics</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/optad/adoptr/blob/main/vignettes/other-endpoints.Rmd" class="external-link"><code>vignettes/other-endpoints.Rmd</code></a></small>
      <div class="d-none name"><code>other-endpoints.Rmd</code></div>
    </div>

    
    
<p>Currently, <code>adoptr</code> supports the optimization of adaptive
two-stage designs with either normally or t-distributed test statistics.
More specifically, it is required that the first stage test statistic,
and the distribution of the second stage test-statistic conditional on
the first-stage test statistic, is either normal or t-distributed.</p>
<p>When individual observations are normally distributed, stage-wise Z-
or T-test statistics fulfill these criteria. In practice, however, there
are many situations where one cannot reasonably assume that individual
observations are sampled from a normal distribution. It is common for
trials to be conducted for binary or time-to-event endpoints, e.g. if
one is interested in investigating the impact of a drug on mortality.
One way to deal with this situation is by transforming the data to a
test-statistic which is approximately normal. In the following, we will
explain how to do so for binary and for time-to-event endpoints.</p>
<p>We will be using the following notation:</p>
<ul>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>X</mi><mi>i</mi><mi>T</mi></msubsup><annotation encoding="application/x-tex">X_i^T</annotation></semantics></math>
will denote an observation of recruit
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
in the treatment arm</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>X</mi><mi>i</mi><mi>C</mi></msubsup><annotation encoding="application/x-tex">X_i^C</annotation></semantics></math>
will denote the observation of recruit
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
in the control arm</li>
<li>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
will denote the group-wise sample size.</li>
</ul>
<div class="section level2">
<h2 id="binary-endpoints">Binary endpoints<a class="anchor" aria-label="anchor" href="#binary-endpoints"></a>
</h2>
<p>Binary endpoints are endpoints where individual observations follow a
Bernoulli distribution,
i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mi>i</mi><mi>T</mi></msubsup><mo>∼</mo><mi>B</mi><mi>i</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><msub><mi>p</mi><mi>T</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">X_i^T \sim Bin(1,p_T)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mi>i</mi><mi>C</mi></msubsup><mo>∼</mo><mi>B</mi><mi>i</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>,</mo><msub><mi>p</mi><mi>C</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">X_i^C\sim Bin(1,p_C)</annotation></semantics></math>.
Our goal is to compare the probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>T</mi></msub><annotation encoding="application/x-tex">p_T</annotation></semantics></math>
of an event in the treatment group with a fixed value (single-arm trial)
or with the probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>C</mi></msub><annotation encoding="application/x-tex">p_C</annotation></semantics></math>
of an event in the control group (two-armed trial). Thus, assuming that
larger probabilities are favorable, we have</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo>:</mo><msub><mi>p</mi><mi>T</mi></msub><mo>≤</mo><msub><mi>p</mi><mi>C</mi></msub><mspace width="1.0em"></mspace><mtext mathvariant="normal">vs.</mtext><mspace width="1.0em"></mspace><msub><mi>H</mi><mn>1</mn></msub><mo>:</mo><msub><mi>p</mi><mi>T</mi></msub><mo>&gt;</mo><msub><mi>p</mi><mi>C</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">
H_0: p_T \leq p_C\quad \text{vs.} \quad H_1:p_T &gt; p_C.
</annotation></semantics></math></p>
<p>To test this hypothesis, one could use the test statistic
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>=</mo><msqrt><mfrac><mi>n</mi><mn>2</mn></mfrac></msqrt><mfrac><mrow><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>T</mi></msub><mo>−</mo><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>C</mi></msub></mrow><msqrt><mrow><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msqrt></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">
U=\sqrt{\frac{n}{2}}\frac{\hat{p}_T-\hat{p}_C}{\sqrt{\hat{p}_0(1-\hat{p}_0)}},
</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>T</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mi>i</mi><mi>n</mi></msubsup><msubsup><mi>X</mi><mi>i</mi><mi>T</mi></msubsup></mrow><annotation encoding="application/x-tex">\hat{p}_T=\frac{1}{n}\sum_i^{n}X_i^T</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>C</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mi>i</mi><mi>n</mi></msubsup><msubsup><mi>X</mi><mi>i</mi><mi>C</mi></msubsup></mrow><annotation encoding="application/x-tex">\hat{p}_C=\frac{1}{n}\sum_i^{n}X_i^C</annotation></semantics></math>
are the maximum likelihood estimators of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>T</mi></msub><annotation encoding="application/x-tex">p_T</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>C</mi></msub><annotation encoding="application/x-tex">p_C</annotation></semantics></math>
and where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo>=</mo><mfrac><mrow><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mi>i</mi><mi>n</mi></msubsup><msubsup><mi>X</mi><mi>i</mi><mi>T</mi></msubsup><mo>+</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><msubsup><mo>∑</mo><mi>i</mi><mi>n</mi></msubsup><msubsup><mi>X</mi><mi>i</mi><mi>C</mi></msubsup></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\hat{p}_0=\frac{\frac{1}{n}\sum_i^{n}X_i^T+\frac{1}{n}\sum_i^{n}X_i^C}{2}</annotation></semantics></math>.</p>
<p>The outcome of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>
is then compared to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mi>f</mi></msub><annotation encoding="application/x-tex">c_f</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mi>e</mi></msub><annotation encoding="application/x-tex">c_e</annotation></semantics></math>,
the first stage boundaries. If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>c</mi><mi>f</mi></msub><mo>,</mo><msub><mi>c</mi><mi>e</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">U\in [c_f,c_e]</annotation></semantics></math>,
we continue the trial and compute a new value for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mn>2</mn></msub><annotation encoding="application/x-tex">U_2</annotation></semantics></math>
in the second stage, where we reject the null if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mn>2</mn></msub><mo>&gt;</mo><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">U_2&gt;c_2</annotation></semantics></math>.</p>
<p>It is a well-known fact that this test statistic is asymptotically
normal, and we will give a proof of this in the next section.</p>
<div class="section level3">
<h3 id="asymptotic-distribution-of-the-test-statistic">Asymptotic distribution of the test statistic<a class="anchor" aria-label="anchor" href="#asymptotic-distribution-of-the-test-statistic"></a>
</h3>
<p>We begin with the difference
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>T</mi></msub><mo>−</mo><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">\hat{p}_T-\hat{p}_C</annotation></semantics></math>.
Using the de Moivre-Laplace theorem, we get that
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>T</mi></msub><mo>−</mo><mi>n</mi><msub><mi>p</mi><mi>T</mi></msub></mrow><msqrt><mi>n</mi></msqrt></mfrac><mover><mo>→</mo><mi>d</mi></mover><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msub><mi>p</mi><mi>T</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>T</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
\frac{n\hat{p}_T-np_T}{\sqrt{n}} \overset{d}{\to} \mathcal{N}(0,p_T(1-p_T)).
</annotation></semantics></math> After defining
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>A</mi><mn>2</mn></msubsup><mo>=</mo><msub><mi>p</mi><mi>T</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>T</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>p</mi><mi>C</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>p</mi><mi>C</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\sigma_A^2=p_T(1-p_T)+p_C(1-p_C)</annotation></semantics></math>,
we obtain
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>n</mi><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>T</mi></msub><mo>−</mo><mi>n</mi><msub><mi>p</mi><mi>T</mi></msub></mrow><msqrt><mi>n</mi></msqrt></mfrac><mo>−</mo><mfrac><mrow><mi>n</mi><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>C</mi></msub><mo>−</mo><mi>n</mi><msub><mi>p</mi><mi>C</mi></msub></mrow><msqrt><mi>n</mi></msqrt></mfrac><mo>=</mo><msqrt><mi>n</mi></msqrt><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>T</mi></msub><mo>−</mo><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>C</mi></msub><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>p</mi><mi>T</mi></msub><mo>−</mo><msub><mi>p</mi><mi>C</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mover><mo>→</mo><mi>d</mi></mover><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><mi>A</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
\frac{n\hat{p}_T-np_T}{\sqrt{n}}-\frac{n\hat{p}_C-np_C}{\sqrt{n}}=\sqrt{n}(\hat{p}_T-\hat{p}_C-(p_T-p_C))\overset{d}{\to}\mathcal{N}(0,\sigma_A^2),
</annotation></semantics></math> so it follows
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>n</mi></msqrt><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>T</mi></msub><mo>−</mo><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>C</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mover><mo>→</mo><mi>d</mi></mover><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><msqrt><mi>n</mi></msqrt><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>p</mi><mi>T</mi></msub><mo>−</mo><msub><mi>p</mi><mi>c</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msubsup><mi>σ</mi><mi>A</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
\sqrt{n}(\hat{p}_T-\hat{p}_C)\overset{d}{\to}\mathcal{N}(\sqrt{n}(p_T-p_c),\sigma_A^2).
</annotation></semantics></math> Applying the continuous mapping
theorem, it results that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>σ</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo>:=</mo><msqrt><mrow><mn>2</mn><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msqrt><mover><mo>→</mo><mi>P</mi></mover><msqrt><mrow><mn>2</mn><msub><mi>p</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msqrt><mo>:=</mo><msub><mi>σ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\hat{\sigma}_0:=\sqrt{2\hat{p}_0(1-\hat{p}_0)} \overset{P}{\to}\sqrt{2p_0(1-p_0)}:=\sigma_0</annotation></semantics></math>,
so by Slutzky’s theorem, we get
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msqrt><mi>n</mi></msqrt><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>T</mi></msub><mo>−</mo><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>C</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><msub><mi>σ</mi><mn>0</mn></msub></mfrac><mo>=</mo><msqrt><mfrac><mi>n</mi><mn>2</mn></mfrac></msqrt><mfrac><mrow><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>T</mi></msub><mo>−</mo><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mi>C</mi></msub></mrow><msqrt><mrow><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msub><mover><mi>p</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msqrt></mfrac><mover><mo>→</mo><mi>d</mi></mover><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><msqrt><mi>n</mi></msqrt><mfrac><mrow><msub><mi>p</mi><mi>T</mi></msub><mo>−</mo><msub><mi>p</mi><mi>C</mi></msub></mrow><msub><mi>σ</mi><mn>0</mn></msub></mfrac><mo>,</mo><mfrac><msubsup><mi>σ</mi><mi>A</mi><mn>2</mn></msubsup><msubsup><mi>σ</mi><mn>0</mn><mn>2</mn></msubsup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
\frac{\sqrt{n}(\hat{p}_T-\hat{p}_C)}{\sigma_0}=\sqrt{\frac{n}{2}}\frac{\hat{p}_T-\hat{p}_C}{\sqrt{\hat{p}_0(1-\hat{p}_0)}}\overset{d}{\to}\mathcal{N}\left(\sqrt{n}\frac{p_T-p_C}{\sigma_0},\frac{\sigma_A^2}{\sigma_0^2}\right).
</annotation></semantics></math> Hence, for sufficiently large
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>
is approximately normal.</p>
<p>Note that under the null hypothesis,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>A</mi><mn>2</mn></msubsup><mo>=</mo><msubsup><mi>σ</mi><mn>0</mn><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\sigma_A^2=\sigma_0^2</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>T</mi></msub><mo>=</mo><msub><mi>p</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">p_T=p_C</annotation></semantics></math>.
Thus, approximately,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>∼</mo><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">U\sim \mathcal{N}(0,1)</annotation></semantics></math>
under
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>H</mi><mn>0</mn></msub><annotation encoding="application/x-tex">H_0</annotation></semantics></math>.</p>
</div>
<div class="section level3">
<h3 id="adoptr-and-binomial-endpoints">
<code>adoptr</code> and binomial endpoints<a class="anchor" aria-label="anchor" href="#adoptr-and-binomial-endpoints"></a>
</h3>
<div class="section level4">
<h4 id="implementation-details">Implementation details<a class="anchor" aria-label="anchor" href="#implementation-details"></a>
</h4>
<p>Currently, <code>adoptr</code> only supports the specification of a
single fixed reference value fo
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>C</mi></msub><annotation encoding="application/x-tex">p_C</annotation></semantics></math>,
while general prior distributions are supported for the effect size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>.</p>
<p>This is a limitation, as uncertainty about the control group rate
cannot be represented in this framework. However, in a trial comparing a
new treatment to an existing one, it is usually reasonable to assume
that some information about the event rate in the control group is
available beforehand.</p>
</div>
<div class="section level4">
<h4 id="example">Example<a class="anchor" aria-label="anchor" href="#example"></a>
</h4>
<p>Assume we want to plan a two-armed trial with an assumed rate of
events in the control group of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>C</mi></msub><mo>=</mo><mn>0.3</mn></mrow><annotation encoding="application/x-tex">p_C=0.3</annotation></semantics></math>.
These parameters are encoded in the <code>DataDistribution</code>
object.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">datadist</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/BinomialDataDistribution-class.html">Binomial</a></span><span class="op">(</span><span class="fl">0.3</span>, two_armed <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Let us furthermore postulate a normal prior distribution for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
with expectation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mn>0.2</mn></mrow><annotation encoding="application/x-tex">\mu=0.2</annotation></semantics></math>
and standard deviation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>=</mo><mn>0.2</mn></mrow><annotation encoding="application/x-tex">\sigma=0.2</annotation></semantics></math>,
which was truncated to the interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><mn>.29</mn><mo>,</mo><mn>0.69</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(-.29,0.69)</annotation></semantics></math>.
It is necessary to use a truncation to ensure that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>T</mi></msub><mo>∈</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">p_T \in (0,1)</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">H_0</span>        <span class="op">&lt;-</span> <span class="fu"><a href="../reference/PointMassPrior-class.html">PointMassPrior</a></span><span class="op">(</span><span class="fl">.0</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">prior</span>      <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ContinuousPrior-class.html">ContinuousPrior</a></span><span class="op">(</span><span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fl">1</span> <span class="op">/</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">pnorm</a></span><span class="op">(</span><span class="fl">0.69</span>, <span class="fl">0.2</span>, <span class="fl">0.2</span><span class="op">)</span> <span class="op">-</span> </span>
<span>                                                   <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">pnorm</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.29</span>, <span class="fl">0.2</span>, <span class="fl">0.2</span><span class="op">)</span><span class="op">)</span> <span class="op">*</span> </span>
<span>                                  <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">dnorm</a></span><span class="op">(</span><span class="va">x</span>, <span class="fl">0.2</span>, <span class="fl">0.2</span><span class="op">)</span>,</span>
<span>                              support <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.29</span>,<span class="fl">0.69</span><span class="op">)</span>,</span>
<span>                              tighten_support <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>We require a maximal type one error of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>≤</mo><mn>0.025</mn></mrow><annotation encoding="application/x-tex">\alpha\leq 0.025</annotation></semantics></math>
and a minimum expected power of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>≥</mo><mn>0.8</mn></mrow><annotation encoding="application/x-tex">\mathbb{E}[1-\beta]\geq 0.8</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">alpha</span>      <span class="op">&lt;-</span> <span class="fl">0.025</span></span>
<span><span class="va">min_epower</span> <span class="op">&lt;-</span> <span class="fl">0.8</span></span>
<span><span class="va">toer_cnstr</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ConditionalPower-class.html">Power</a></span><span class="op">(</span><span class="va">datadist</span>, <span class="va">H_0</span><span class="op">)</span> <span class="op">&lt;=</span> <span class="va">alpha</span></span>
<span><span class="va">epow_cnstr</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ConditionalPower-class.html">Power</a></span><span class="op">(</span><span class="va">datadist</span>, <span class="fu"><a href="../reference/condition.html">condition</a></span><span class="op">(</span><span class="va">prior</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.0</span>,<span class="fl">0.69</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">&gt;=</span> <span class="va">min_epower</span></span></code></pre></div>
<p>Next, we need to choose an objective function, which will be the
expected sample size under the chosen prior distribution for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
in this example. After having chosen a starting point for the
optimization procedure, we use the <code>minimize</code> function to
determine the optimal design parameters.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ess</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ConditionalSampleSize-class.html">ExpectedSampleSize</a></span><span class="op">(</span><span class="va">datadist</span>,<span class="va">prior</span><span class="op">)</span></span>
<span></span>
<span><span class="va">init</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get_initial_design.html">get_initial_design</a></span><span class="op">(</span><span class="fl">0.2</span>,<span class="fl">0.025</span>,<span class="fl">0.2</span><span class="op">)</span></span>
<span></span>
<span><span class="va">opt_design</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/minimize.html">minimize</a></span><span class="op">(</span><span class="va">ess</span>,<span class="fu"><a href="../reference/subject_to.html">subject_to</a></span><span class="op">(</span><span class="va">toer_cnstr</span>,<span class="va">epow_cnstr</span><span class="op">)</span>, </span>
<span>                       initial_design <span class="op">=</span> <span class="va">init</span>, check_constraints <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; Warning in minimize(ess, subject_to(toer_cnstr, epow_cnstr), initial_design =</span></span>
<span><span class="co">#&gt; init, : NLOPT_MAXEVAL_REACHED: Optimization stopped because maxeval (above) was</span></span>
<span><span class="co">#&gt; reached.</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">opt_design</span><span class="op">$</span><span class="va">design</span><span class="op">)</span></span></code></pre></div>
<p><img src="other-endpoints_files/figure-html/unnamed-chunk-5-1.png" width="672"></p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="time-to-event-endpoints">Time-to-event endpoints<a class="anchor" aria-label="anchor" href="#time-to-event-endpoints"></a>
</h2>
<p>Time-to-event endpoints are another common type of endpoint used in
clinical trials. Time-to-event data is two-dimensional and consists of
an indicator denoting the occurrence of an event or censoring, and a
time of the event or censoring.</p>
<p>A common effect measure for time-to-event endpoints is the so called
hazard-ratio, which is the ratio of hazard functions between two groups
or the ratio of the hazard of one group and a postulated baseline
hazard.</p>
<p>In the following, the hazard ratio will be denoted by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>:=</mo><mfrac><mrow><msub><mi>λ</mi><mi>C</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><msub><mi>λ</mi><mi>T</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">\theta := \frac{\lambda_C(t)}{\lambda_T(t)}</annotation></semantics></math>,
and we will assume that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
is constant over time. Assuming that less hazard is favorable, the
resulting hypotheses to be tested are</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mn>0</mn></msub><mo>:</mo><mi>θ</mi><mo>≤</mo><mn>1</mn><mspace width="1.0em"></mspace><mtext mathvariant="normal">vs.</mtext><mspace width="1.0em"></mspace><msub><mi>H</mi><mn>1</mn></msub><mo>:</mo><mi>θ</mi><mo>&gt;</mo><mn>1</mn><mi>.</mi></mrow><annotation encoding="application/x-tex">
H_0: \theta\leq 1 \quad \text{vs.} \quad H_1: \theta &gt;1.
</annotation></semantics></math></p>
<p>Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">1,\dots,J</annotation></semantics></math>
be the distinct times of observed events in either group and let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mrow><mi>T</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>,</mo><msub><mi>n</mi><mrow><mi>C</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">n_{T,j}, n_{C,j}</annotation></semantics></math>
be the number of subjects, who neither had an event nor have been
censored. Additionally, let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mrow><mi>T</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>,</mo><msub><mi>O</mi><mrow><mi>C</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">O_{T,j},O_{C,j}</annotation></semantics></math>
denote the observed number of events at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>.
In the following we assume that there are no ties, so
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mrow><mi>T</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>,</mo><msub><mi>O</mi><mrow><mi>C</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">O_{T,j},O_{C,j}\in \{0,1\}</annotation></semantics></math>.
Define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>j</mi></msub><mo>:=</mo><msub><mi>n</mi><mrow><mi>T</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>n</mi><mrow><mi>C</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">n_j:=n_{T,j}+n_{C,j}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mi>j</mi></msub><mo>:=</mo><msub><mi>O</mi><mrow><mi>T</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>O</mi><mrow><mi>C</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">O_j:= O_{T,j}+O_{C,j}</annotation></semantics></math>.
Under the null, the hazard functions of the groups are equal. Thus, for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mi>T</mi><mo>,</mo><mi>C</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">i \in \{T,C\}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">O_{i,j}</annotation></semantics></math>
can be regarded as the number of events in a draw of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">n_{i,j}</annotation></semantics></math>,
where the population has size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>j</mi></msub><annotation encoding="application/x-tex">n_j</annotation></semantics></math>.
Therefore,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">O_{i,j}</annotation></semantics></math>
follows a hypergeometric distribution,
i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>∼</mo><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>n</mi><mi>j</mi></msub><mo>,</mo><msub><mi>O</mi><mi>j</mi></msub><mo>,</mo><msub><mi>n</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O_{i,j}\sim h(n_j,O_j,n_{i,j})</annotation></semantics></math>.
This distribution has an expected value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>:=</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>O</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msub><mi>n</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mfrac><msub><mi>O</mi><mi>j</mi></msub><msub><mi>n</mi><mi>j</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">E_{i,j}:=\mathbb{E}[O_{i,j}]=n_{i,j}\frac{O_j}{n_j}</annotation></semantics></math>
and variance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>:=</mo><mtext mathvariant="normal">Var</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>O</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>E</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><msub><mi>n</mi><mi>j</mi></msub><mo>−</mo><msub><mi>O</mi><mi>j</mi></msub></mrow><msub><mi>n</mi><mi>j</mi></msub></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><msub><mi>n</mi><mi>j</mi></msub><mo>−</mo><msub><mi>n</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><mrow><msub><mi>n</mi><mi>j</mi></msub><mo>−</mo><mn>1</mn></mrow></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">V_{i,j}:=\text{Var}(O_{i,j})=E_{i,j}\left(\frac{n_j-O_j}{n_j}\right)\left(\frac{n_j-n_{i,j}}{n_j-1}\right)</annotation></semantics></math>.
Using these definitions, we can define the so-called log-rank test
statistic as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><msub><mi>L</mi><mi>T</mi></msub><mo>:=</mo><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>J</mi></munderover><msub><mi>O</mi><mrow><mi>T</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>−</mo><msub><mi>E</mi><mrow><mi>T</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><msqrt><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>J</mi></munderover><msub><mi>V</mi><mrow><mi>T</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow></msqrt></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
L=L_T:=\frac{\sum_{j=1}^J O_{T,j}-E_{T,j}}{\sqrt{\sum_{j=1}^J V_{T,j}}}.
</annotation></semantics></math> Note that it does not matter whether we
consider
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>T</mi></msub><annotation encoding="application/x-tex">L_T</annotation></semantics></math>
or the analogously defined statistic
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>C</mi></msub><annotation encoding="application/x-tex">L_C</annotation></semantics></math>,
both of them yield the same results, so we abbreviate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>T</mi></msub><annotation encoding="application/x-tex">L_T</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>.
By the central limit theorem, it is easy to see that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mover><mo>→</mo><mi>d</mi></mover><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">L \overset{d}{\to} \mathcal{N}(0,1)</annotation></semantics></math>.
Under the alternative, it can be shown that, approximately,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∼</mo><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><msqrt><mi>J</mi></msqrt><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">L \sim \mathcal{N}(\text{log}(\theta)\frac{1}{2}\sqrt{J},1)</annotation></semantics></math>.
If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ψ</mi><annotation encoding="application/x-tex">\psi</annotation></semantics></math>
is the average probability of an event per recruit in both arms (also
known as the event rate),
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
can be replaced by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>⋅</mo><mi>n</mi><mo>⋅</mo><mi>ψ</mi></mrow><annotation encoding="application/x-tex">2 \cdot n \cdot \psi</annotation></semantics></math>
(where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
denotes, like in the previous sections, the number of recruits per
group). Thus, by by postulating an event probability, we can calculate
the number of recruits per groups that would be required to achieve a
specific number of events, and by extensions, a specific power. In
<code>adoptr</code>, the parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ψ</mi><annotation encoding="application/x-tex">\psi</annotation></semantics></math>
needs to be pre-specified in order to obtain a one-parametric
distribution (the other parameter being
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>),
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ψ</mi><annotation encoding="application/x-tex">\psi</annotation></semantics></math>
is assumed to be fixed over time. This is similar to the case of binary
endpoints, where the response rate in the control group
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>C</mi></msub><annotation encoding="application/x-tex">p_C</annotation></semantics></math>
had to be a constant value.</p>
<div class="section level3">
<h3 id="survival-analysis-and-adaptive-designs">Survival analysis and adaptive designs<a class="anchor" aria-label="anchor" href="#survival-analysis-and-adaptive-designs"></a>
</h3>
<div class="section level4">
<h4 id="notation">Notation<a class="anchor" aria-label="anchor" href="#notation"></a>
</h4>
<p>We expand the previous notation by an index
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">k\in \{1,2\}</annotation></semantics></math>
denoting the current stage. We observe
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mn>1</mn></msub><annotation encoding="application/x-tex">d_1</annotation></semantics></math>
events until the interim analysis at times
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>J</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{1,\dots,J_1\}</annotation></semantics></math>,
and we observe
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mn>2</mn></msub><annotation encoding="application/x-tex">d_2</annotation></semantics></math>
events in total until the final analysis at times
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>J</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{1,\dots,J_2\}</annotation></semantics></math>.
We stress that, in this notation,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mn>2</mn></msub><annotation encoding="application/x-tex">d_2</annotation></semantics></math>
denotes the cumulative number of events in both stages. Furthermore, let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">O_{i,j,k}</annotation></semantics></math>
be the number of observed events in arm
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mi>T</mi><mo>,</mo><mi>C</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">i\in \{T,C\}</annotation></semantics></math>
at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>J</mi><mi>k</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">j \in \{1,\dots,J_k\}</annotation></semantics></math>
in stage
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">k \in \{1,2\}</annotation></semantics></math>.
Like in the previous section, let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>=</mo><mi>𝔼</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>O</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><msub><mi>n</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mfrac><msub><mi>O</mi><mrow><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><msub><mi>n</mi><mrow><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub></mfrac></mrow><annotation encoding="application/x-tex">E_{i,j,k}= \mathbb{E}[O_{i,j,k}]=n_{i,j,k}\frac{O_{j,k}}{n_{j,k}}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">n_{i,j,k}</annotation></semantics></math>
is the number of patients that have not had an event until the end of
stage
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>,
and let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>O</mi><mrow><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>=</mo><msub><mi>O</mi><mrow><mi>T</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>+</mo><msub><mi>O</mi><mrow><mi>C</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">O_{j,k}=O_{T,j,k}+O_{C,j,k}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mrow><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>=</mo><msub><mi>n</mi><mrow><mi>T</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>+</mo><msub><mi>n</mi><mrow><mi>C</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">n_{j,k}=n_{T,j,k}+n_{C,j,k}</annotation></semantics></math>.
Likewise, we can define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>V</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">V_{i,j,k}</annotation></semantics></math>
analogously to the previous section. The cumulative log-rank test
statistic up to stage
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">k \in \{1, 2\}</annotation></semantics></math>
can then be defined as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>k</mi></msub><mo>=</mo><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>J</mi><mi>k</mi></msub></munderover><msub><mi>O</mi><mrow><mi>T</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub><mo>−</mo><msub><mi>E</mi><mrow><mi>T</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub></mrow><msqrt><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>J</mi><mi>k</mi></msub></munderover><msub><mi>V</mi><mrow><mi>T</mi><mo>,</mo><mi>j</mi><mo>,</mo><mi>k</mi></mrow></msub></mrow></msqrt></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
L_k=\frac{\sum_{j=1}^{J_k} O_{T,j,k}-E_{T,j,k}}{\sqrt{\sum_{j=1}^{J_k} V_{T,j,k}}}.
</annotation></semantics></math></p>
</div>
<div class="section level4">
<h4 id="dependency-issues-and-solutions">Dependency issues and solutions<a class="anchor" aria-label="anchor" href="#dependency-issues-and-solutions"></a>
</h4>
<p>For normal distributed endpoints, the stage-wise test statistics come
from independent cohorts, which makes the calculation of their joint
distributions straightforward.</p>
<p>In survival analysis, it is possible to have patients that have been
recruited during the first stage, but have not had an event at the point
of the interim analysis. Those provide information for both stages: in
the first stage, we know that they survived, and in the second stage,
they might die or even survive until the end of the trial. This makes
the construction of a pair of suitable test statistics more
challenging.</p>
<p>In the following, we will present two methods to avoid these
issues.</p>
<div class="section level5">
<h5 id="solution-1-independent-increments">Solution 1: Independent increments<a class="anchor" aria-label="anchor" href="#solution-1-independent-increments"></a>
</h5>
<p>It can be shown that the statistic
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mn>2</mn></msub><mo>:=</mo><mfrac><mrow><msqrt><msub><mi>d</mi><mn>2</mn></msub></msqrt><msub><mi>L</mi><mn>2</mn></msub><mo>−</mo><msqrt><msub><mi>d</mi><mn>1</mn></msub></msqrt><msub><mi>L</mi><mn>1</mn></msub></mrow><msqrt><mrow><msub><mi>d</mi><mn>2</mn></msub><mo>−</mo><msub><mi>d</mi><mn>1</mn></msub></mrow></msqrt></mfrac></mrow><annotation encoding="application/x-tex">
Z_2:= \frac{\sqrt{d_2}L_2-\sqrt{d_1}L_1}{\sqrt{d_2-d_1}}
</annotation></semantics></math> is approximately distributed according
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="normal">log</mtext><mrow><mo stretchy="true" form="prefix">(</mo><mi>θ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><msqrt><mrow><msub><mi>d</mi><mn>2</mn></msub><mo>−</mo><msub><mi>d</mi><mn>1</mn></msub></mrow></msqrt><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{N}(\text{log}(\theta)\frac{1}{2}\sqrt{d_2-d_1},1)</annotation></semantics></math>,
and that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mn>1</mn></msub><annotation encoding="application/x-tex">L_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Z</mi><mn>2</mn></msub><annotation encoding="application/x-tex">Z_2</annotation></semantics></math>
are approximately independent.</p>
<p>The recruitment and testing procedure is now as follows: During the
accrual time, recruit approximately
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><msub><mi>d</mi><mn>1</mn></msub><mrow><mn>2</mn><mi>ψ</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{d_1}{2\psi}</annotation></semantics></math>
patients per group and conduct the interim analysis after having
observed
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mn>1</mn></msub><annotation encoding="application/x-tex">d_1</annotation></semantics></math>
events overall.</p>
<p>Assume,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>
patients have not had an event until the interim analysis. These
patients are censored for the computation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mn>1</mn></msub><annotation encoding="application/x-tex">L_1</annotation></semantics></math>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mn>1</mn></msub><annotation encoding="application/x-tex">L_1</annotation></semantics></math>
is then compared to the futility and efficacy boundaries
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mi>f</mi></msub><annotation encoding="application/x-tex">c_f</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mi>e</mi></msub><annotation encoding="application/x-tex">c_e</annotation></semantics></math>,
and recruitment is stopped if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub><mo>&lt;</mo><msub><mi>c</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">L_1 &lt; c_f</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub><mo>&gt;</mo><msub><mi>c</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">L_1 &gt; c_e</annotation></semantics></math>.
If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>f</mi></msub><mo>≤</mo><msub><mi>L</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>c</mi><mi>e</mi></msub></mrow><annotation encoding="application/x-tex">c_f \leq L_1 \leq c_e</annotation></semantics></math>,
recruitment of patients for the second stage will continue.</p>
<p>The number of patients to be recruited in the second stage is
calculated so that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>L</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">d_2(L_1)</annotation></semantics></math>
events are expected to be observed in the second stage. Similarly to the
normal case, the required number of events is a function of the
first-stage test statistic. The observation of these
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>L</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">d_2(L_1)</annotation></semantics></math>
events will trigger the conduct of the final analysis, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Z</mi><mn>2</mn></msub><annotation encoding="application/x-tex">Z_2</annotation></semantics></math>
is compared to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>L</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c_2(L_1)</annotation></semantics></math>.</p>
</div>
<div class="section level5">
<h5 id="solution-2-left-truncation-at-the-second-stage">Solution 2: Left truncation at the second stage<a class="anchor" aria-label="anchor" href="#solution-2-left-truncation-at-the-second-stage"></a>
</h5>
<p>Another approach uses left truncation and right censoring. In the
following,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>R</mi><mi>i</mi></msub><annotation encoding="application/x-tex">R_i</annotation></semantics></math>
stands for the calendar time of entry for individual
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>.
Furthermore, let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mi>i</mi></msub><annotation encoding="application/x-tex">T_i</annotation></semantics></math>
be their time from entry to the event and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mi>i</mi></msub><annotation encoding="application/x-tex">C_i</annotation></semantics></math>
their time from entry to censoring. Assume that these values are
independent and let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo>,</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><msub><mi>c</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r_i,t_i,c_i</annotation></semantics></math>
be realizations of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub><mo>,</mo><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i,T_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>C</mi><mi>i</mi></msub><annotation encoding="application/x-tex">C_i</annotation></semantics></math>.
Additionally, we denote the calendar time of the interim analysis by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mrow><mi>I</mi><mi>n</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">t_{Int}</annotation></semantics></math>
and the calender time of the final analysis by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mrow><mi>F</mi><mi>i</mi><mi>n</mi></mrow></msub><annotation encoding="application/x-tex">t_{Fin}</annotation></semantics></math>.</p>
<p>Let individual
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
be recruited before the interim analysis. Define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mn>1</mn></mrow></msub><mo>:=</mo><mo>min</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><msub><mi>c</mi><mi>i</mi></msub><mo>,</mo><msub><mi>t</mi><mrow><mi>I</mi><mi>n</mi><mi>t</mi></mrow></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">y_{i,1}:=\min \{t_i,c_i,t_{Int}\}</annotation></semantics></math>,
i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">y_{i,1}</annotation></semantics></math>
can be interpreted as the minimum time until “something” happens to
individual
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
in the first stage (either the interim analysis is conducted,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
had an event or they were censored). The risk interval for the
first-stage test statistic is now defined to be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mn>1</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0,y_{i,1})</annotation></semantics></math>,
which means that individual
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
belongs to the risk set at the event time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>j</mi></msub><annotation encoding="application/x-tex">t_j</annotation></semantics></math>
if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>min</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>c</mi><mi>i</mi></msub><mo>,</mo><msub><mi>t</mi><mrow><mi>I</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>−</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">}</mo><mo>≥</mo><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\min \{c_i,t_{Int}-r_i\}\geq x_j</annotation></semantics></math>.</p>
<p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
has not had an event yet in the first stage, was not lost to follow-up
yet in the first stage, or if they were recruited in the second stage,
we define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow></msub><mo>:=</mo><mo>min</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><msub><mi>c</mi><mi>i</mi></msub><mo>,</mo><msub><mi>t</mi><mrow><mi>F</mi><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">y_{i,2}:=\min\{t_i,c_i,t_{Fin}\}</annotation></semantics></math>.
As before,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow></msub><annotation encoding="application/x-tex">y_{i,2}</annotation></semantics></math>
can be interpreted as the minimum time until something happens to
individual
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
in the second stage: Either the final analysis is conducted,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
had an event or was censored. The risk interval for an individual
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
for the second stage test-statistic is then defined as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mo>max</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>t</mi><mrow><mi>I</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>−</mo><msub><mi>r</mi><mi>i</mi></msub><mo>,</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mn>2</mn></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\max(t_{Int}-r_i, 0),y_{i,2})</annotation></semantics></math>.
This definition takes into account that that a patient
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
who was recruited in the first stage, but had no event until the interim
analysis, has already provided the information of “no event” in the time
span
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msub><mi>t</mi><mrow><mi>I</mi><mi>n</mi><mi>t</mi></mrow></msub><mo>−</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0, t_{Int}-r_i)</annotation></semantics></math>
for the interim analysis. To avoid double-counting in the second
analysis, we say that this patient is not in the risk set until this
time span is over.</p>
<p>Using this idea, one can conduct the analyses of the trial according
to the following instructions: For the interim analysis, the procedure
is the same as for the independent increment solution,
i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mn>1</mn></msub><annotation encoding="application/x-tex">L_1</annotation></semantics></math>
is computed in the usual way and compared to the futility and efficacy
boundaries
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mi>f</mi></msub><annotation encoding="application/x-tex">c_f</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mi>e</mi></msub><annotation encoding="application/x-tex">c_e</annotation></semantics></math>.
If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>c</mi><mi>e</mi></msub><mo>,</mo><msub><mi>c</mi><mi>f</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">L_1 \in [c_e,c_f]</annotation></semantics></math>
(i.e. the trial is not stopped for early efficacy or futility), we
continue the observation and recruit new patients, such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>L</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">d_2(L_1)</annotation></semantics></math>
events are expected to be observed in the second stage.</p>
<p>The second-stage test statistic is where the two methods differ.
Here, the idea is to construct a log-rank test statistic
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mrow><mi>T</mi><mi>r</mi><mi>u</mi><mi>n</mi><mi>c</mi></mrow></msub><annotation encoding="application/x-tex">L_{Trunc}</annotation></semantics></math>
comprised of the data of the patients who were recruited after the
interim analysis, who contribute to the test statistic in the usual way,
and the patients recruited before the interim analysis who have not had
an event yet, who contribute as left (and possibly right) truncated
datapoints. In theory, this is can be achieved by appropriately
adjusting
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>j</mi></msub><annotation encoding="application/x-tex">n_j</annotation></semantics></math>
for the respective event timings
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
in the definition of the log-rank statistic, and in practice, the
<code><a href="https://rdrr.io/pkg/survival/man/coxph.html" class="external-link">survival::coxph</a></code> method can handle datasets of the
aforementioned structure.</p>
</div>
<div class="section level5">
<h5 id="example-1">Example<a class="anchor" aria-label="anchor" href="#example-1"></a>
</h5>
<p>In <code>adoptr</code>, trial designs to investigate time-to-event
endpoints can be represented in objects of the class
<code>TwoStageDesignSurvival</code>. These designs consist of slots for
the first stage efficacy and futility boundaries <code>cf</code> and
<code>ce</code>, a slot for the required number of events in the first
stage <code>n1</code>, slots for the spline interpolation points for the
<code>n2</code> and <code>c2</code> functions, and a postulated event
rate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ψ</mi><annotation encoding="application/x-tex">\psi</annotation></semantics></math>.</p>
<p>Two things are important to note here: First, the functions
<code>n1</code> and <code>n2</code> will return the number of required
events, not the number of recruits that would be required to achieve
this number of events in expectation. Information on the latter is
instead provided in the <code>summary</code> output of a design. Second,
for one-armed trials, <code>n1</code> and <code>n2</code> are the
overall number of required events, while for two-armed trials,
<code>n1</code> and <code>n2</code> return half of the overall number of
required events. This is analogous to the case with normally distributed
outcomes, where <code>n1</code> and <code>n2</code> return the
group-wise sample sizes. However, calling <code>n1</code> and
<code>n2</code> the group-wise number of events would be a misnomer, as
the timings of the interim analyses are based on the overall number of
events, and the number of events are unlikely to be exactly equal across
the two groups.</p>
<p>Let us say we want to plan a two-armed trial trial, where we assume
an average rate of events of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ψ</mi><mo>=</mo><mn>0.7</mn></mrow><annotation encoding="application/x-tex">\psi=0.7</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">datadist</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/SurvivalDataDistribution-class.html">Survival</a></span><span class="op">(</span><span class="fl">0.7</span>, two_armed <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>The postulated rate of events
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ψ</mi><annotation encoding="application/x-tex">\psi</annotation></semantics></math>
is saved in the <code>DataDistribution</code> object and will be handed
down to any design optimized with respect to this distribution. It will
be used to convert the required number of events
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>
to the estimated number of required recruits via
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mi>d</mi><mi>ψ</mi></mfrac><annotation encoding="application/x-tex">\frac{d}{\psi}</annotation></semantics></math>,
but it has no other uses. All other design parameters are invariant with
respect to the choice of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ψ</mi><annotation encoding="application/x-tex">\psi</annotation></semantics></math>.</p>
<p>Effect sizes for time-to-event trials are formulated with respect to
a hazard ratio. For our example, we assume
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\theta=1</annotation></semantics></math>
for the null hypothesis, and a point alternative hypothesis of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mn>1.7</mn></mrow><annotation encoding="application/x-tex">\theta=1.7</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">H_0</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/PointMassPrior-class.html">PointMassPrior</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">H_1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/PointMassPrior-class.html">PointMassPrior</a></span><span class="op">(</span><span class="fl">1.7</span>, <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>Our desired design should have a maximal type I error
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>≤</mo><mn>0.025</mn></mrow><annotation encoding="application/x-tex">\alpha\leq 0.025</annotation></semantics></math>
and a minimum power of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≥</mo><mn>0.8</mn></mrow><annotation encoding="application/x-tex">(1-\beta)\geq 0.8</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">alpha</span> <span class="op">&lt;-</span> <span class="fl">0.025</span></span>
<span><span class="va">min_power</span> <span class="op">&lt;-</span> <span class="fl">0.8</span></span>
<span><span class="va">toer_con</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ConditionalPower-class.html">Power</a></span><span class="op">(</span><span class="va">datadist</span>,<span class="va">H_0</span><span class="op">)</span> <span class="op">&lt;=</span> <span class="va">alpha</span></span>
<span><span class="va">pow_con</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ConditionalPower-class.html">Power</a></span><span class="op">(</span><span class="va">datadist</span>,<span class="va">H_1</span><span class="op">)</span> <span class="op">&gt;=</span> <span class="va">min_power</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">exp_no_events</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ConditionalSampleSize-class.html">ExpectedNumberOfEvents</a></span><span class="op">(</span><span class="va">datadist</span>, <span class="va">H_1</span><span class="op">)</span></span>
<span><span class="va">init</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get_initial_design.html">get_initial_design</a></span><span class="op">(</span><span class="fl">1.7</span>, <span class="fl">0.025</span>, <span class="fl">0.2</span>, dist<span class="op">=</span><span class="va">datadist</span><span class="op">)</span></span>
<span><span class="va">opt_survival</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/minimize.html">minimize</a></span><span class="op">(</span><span class="va">exp_no_events</span>, <span class="fu"><a href="../reference/subject_to.html">subject_to</a></span><span class="op">(</span><span class="va">toer_con</span>,<span class="va">pow_con</span><span class="op">)</span>,</span>
<span>                         initial_design <span class="op">=</span> <span class="va">init</span>, check_constraints<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">opt_survival</span><span class="op">$</span><span class="va">design</span><span class="op">)</span></span>
<span><span class="co">#&gt; For two-armed trials: nevs denotes half of the overall number of required events. nrec denotes the resulting group-wise sample size.</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; TwoStageDesignSurvival: nevs1= 32 --&gt; nrec1= 46</span></span>
<span><span class="co">#&gt;           futility |                  continue                 | efficacy</span></span>
<span><span class="co">#&gt;       x1:     0.79 |  0.83  0.98  1.24  1.54  1.85  2.10  2.25 |  2.29</span></span>
<span><span class="co">#&gt;   c2(x1):     +Inf | +2.17 +2.02 +1.77 +1.43 +1.00 +0.52 +0.07 |  -Inf</span></span>
<span><span class="co">#&gt;   nevs2(x1):     0 |    45    42    38    32    24    17    12 |     0</span></span>
<span><span class="co">#&gt;   nrec2(x1):     0 |    64    60    54    45    35    25    17 |     0</span></span>
<span><span class="co">#&gt; </span></span></code></pre></div>
<p>It should be noted that the number of required events
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>⋅</mo></mrow><annotation encoding="application/x-tex">2\cdot</annotation></semantics></math><code>nevs1</code>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>⋅</mo></mrow><annotation encoding="application/x-tex">2\cdot</annotation></semantics></math><code>nevs2(x1)</code> are the important information thresholds to be
adhered to for testing purposes. <code>nrec1</code> and and
<code>nrec2(x1)</code> only serve as rough estimates for the required
number of recruits to achieve the target number of events. If additional
information about e.g. time-dependence of baseline hazards is available,
it may be worthwhile to use a more sophisticated approach than the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mi>d</mi><mi>ψ</mi></mfrac><annotation encoding="application/x-tex">\frac{d}{\psi}</annotation></semantics></math>
formula to estimate the number of required subjects.</p>
</div>
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Kevin Kunzmann, Maximilian Pilz, Jan Meis, Nico Bruder.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
