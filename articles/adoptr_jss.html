<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R • adoptr</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">adoptr</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.1.1.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../index.html"><span class="fa fa-home fa-lg"></span></a></li>
<li class="nav-item"><a class="nav-link" href="../articles/adoptr.html">Get started</a></li>
<li class="active nav-item"><a class="nav-link" href="../articles/adoptr_jss.html">Overview Paper</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/working-with-priors.html">Working with Priors</a></li>
    <li><a class="dropdown-item" href="../articles/conditional-scores.html">Conditional Scores</a></li>
    <li><a class="dropdown-item" href="../articles/composite-scores.html">Composite Scores</a></li>
    <li><a class="dropdown-item" href="../articles/defining-new-scores.html">Definining New Scores</a></li>
    <li><a class="dropdown-item" href="../articles/other-endpoints.html">Non-normal Endpoints</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/optad/adoptr"><span class="fa fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>The adoptr Package: Adaptive Optimal Designs for Clinical Trials in R</h1>
                        <h4 data-toc-skip class="author">Kevin
Kunzmann</h4>
            <address class="author_afil">
      Cambridge
University<br><a class="author_email" href="mailto:#"></a><a href="mailto:kevin.kunzmann@mrc-bsu.cam.ac.uk" class="email">kevin.kunzmann@mrc-bsu.cam.ac.uk</a>
      </address>
                              <h4 data-toc-skip class="author">Maximilian
Pilz</h4>
            <address class="author_afil">
      University of
Heidelberg<br><a class="author_email" href="mailto:#"></a><a href="mailto:pilz@imbi.uni-heidelberg.de" class="email">pilz@imbi.uni-heidelberg.de</a>
      </address>
                              <h4 data-toc-skip class="author">Carolin
Herrmann</h4>
            <address class="author_afil">
      Charité Berlin and Berlin Insitute of
Health<br><a class="author_email" href="mailto:#"></a><a href="mailto:carolin.herrmann@charite.de" class="email">carolin.herrmann@charite.de</a>
      </address>
                              <h4 data-toc-skip class="author">Geraldine
Rauch</h4>
            <address class="author_afil">
      Charité Berlin and Berlin Insitute of
Health<br><a class="author_email" href="mailto:#"></a><a href="mailto:geraldine.rauch@charite.de" class="email">geraldine.rauch@charite.de</a>
      </address>
                              <h4 data-toc-skip class="author">Meinhard
Kieser</h4>
            <address class="author_afil">
      University of
Heidelberg<br><a class="author_email" href="mailto:#"></a><a href="mailto:meinhard.kieser@imbi.uni-heidelberg.de" class="email">meinhard.kieser@imbi.uni-heidelberg.de</a>
      </address>
                  
            <h4 data-toc-skip class="date">2024-10-03</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/optad/adoptr/blob/main/vignettes/adoptr_jss.Rmd" class="external-link"><code>vignettes/adoptr_jss.Rmd</code></a></small>
      <div class="d-none name"><code>adoptr_jss.Rmd</code></div>
    </div>

    
        <div class="abstract">
      <p class="abstract">Abstract</p>
      <p>Even though adaptive two-stage designs with unblinded interim
      analyses are becoming increasingly popular in clinical trial
      designs, there is a lack of statistical software to make their
      application more straightforward. The package
      <strong>adoptr</strong> fills this gap for the common case of
      two-stage one- or two-arm trials with (approximately) normally
      distributed outcomes. In contrast to previous approaches,
      <strong>adoptr</strong> optimizes the entire design upfront which
      allows maximal efficiency. To facilitate experimentation with
      different objective functions, <strong>adoptr</strong> supports a
      flexible way of specifying both (composite) objective scores and
      (conditional) constraints by the user. Special emphasis was put on
      providing measures to aid practitioners with the validation
      process of the package.</p>
    </div>
    
<p>This manuscript is published in the Journal of Statistical Software
under .</p>
<div class="section level2">
<h2 id="background">Background<a class="anchor" aria-label="anchor" href="#background"></a>
</h2>
<p>Confirmatory clinical trials are conducted in a strictly regulated
environment. A key quality criterion put forward by the relevant
agencies (<span class="citation">US Food and Drug Administration et al.
(2019)</span>, <span class="citation">Committee for Medicinal Products
for Human Use and others (2007)</span>) for a study that is supposed to
provide evidence for the regulatory acceptance of a new drug or
treatment is strict type one error rate control. This requirement was
often seen as conflicting with the perceived need to make trials more
flexible by, e.g., early stopping for futility, group-sequential
enrollment, or even adaptive sample size recalculation. An excellent
historical review of the development of the field of adaptive clinical
trial designs and the struggles along the way is given in <span class="citation">Bauer et al. (2015)</span>.</p>
<p>In this manuscript, the focus lies exclusively on adaptive two-stage
designs with one unblinded interim analysis. Both early stopping for
futility and efficacy are allowed and the final sample size as well as
the critical value to reject the null hypothesis is chosen in a
data-driven way. There is a plethora of methods for modifying the design
of an ongoing trial based on interim results without compromising type
one error rate control <span class="citation">(Bauer et al. 2015)</span>
but the criteria for deciding <em>which</em> adaptation should be
performed during an interim analysis and <em>when</em> to perform the
interim analysis are still widely based on heuristics. Bauer <em>et
al.</em> mention this issue of guiding adaptive decisions at interim in
a principled (i.e., ‘optimal’) way by stating that ‘[t]he question might
arise if potential decisions made at interim stages might not be better
placed to the upfront planning stage.’ Following <span class="citation">Mehta and Pocock (2011)</span>, <span class="citation">Jennison and Turnbull (2015)</span> developed a
principle approach to optimal interim sample size modifications, i.e.,
to conduct the interim decision (conditional on interim results) such
that it optimizes an unconditional performance score. Their approach,
however, was still restricted unnecessarily. Recently, <span class="citation">Pilz et al. (2019)</span> extended the work to a fully
general variational problem where the optimization problem for any given
performance score (optionally under further constraints) is solved over
both the sample size adaptation function and the critical value function
and the time point of the interim decision simultaneously. This approach
is an application of ideas which have been put forward in single-arm
trials with binary endpoint for several years (<span class="citation">Englert and Kieser (2013)</span>, <span class="citation">Kunzmann and Kieser (2016)</span>, <span class="citation">Kunzmann and Kieser (2020)</span>) to a setting with
continuous test statistics. Clearly, by relaxing the problem to
continuous sample sizes and test statistics, the theory becomes much
more tractable, and important connections between conditional and
unconditional optimality can be discussed much easier <span class="citation">(Pilz et al. 2019)</span>.</p>
<p>A key insight from this recent development is the fact that the true
challenge in designing an adaptive trial is less the technical
methodology for controlling the type one error rate but rather the
choice of the optimality criterion. This issue is much less pressing in
single-stage designs since most sensible criteria will be equivalent to
minimizing the overall sample size. Thus, in this case, a ‘design’ is
often completely specified by given power and type one error rate
constraints. For the more complex adaptive designs, however, there are
much more sensible criteria (minimize maximal sample size, expected
sample size, expected costs, etc.) and the balance between conditional
and unconditional properties must be explicitly specified (cf. Section
<a href="#sec:Examples">6</a>). This added complexity might be seen as
daunting by practitioners, but it is also a chance for tailoring
adaptive designs more specifically to a particular situation. The
<strong>R</strong>-package <span class="citation">(R Core Team
2019)</span> <strong>adoptr</strong> aims at providing a simple yet
customizable interface to specifying a broad class of objective
functions and constraints for single- or two-arm, one- or two-stage
designs with approximately normally distributed endpoints. The goal of
<strong>adoptr</strong> is to enable relatively easy experimentation
with different notions of optimality to shift the focus from
<em>how</em> to optimize to <em>what</em> to optimize.</p>
<p>In the following, we first give a definition of the problem setting
addressed in <strong>adoptr</strong> and the technicalities of
translating the underlying variational problem to a simple multivariate
optimization problem before motivating the need for an
<strong>R</strong>-package. We then present the core functionality of
<strong>adoptr</strong> before addressing the issue of facilitating
validation of open-source software in a regulated environment and
discussing potential future work on <strong>adoptr</strong>.</p>
</div>
<div class="section level2">
<h2 id="sec:setting">Setting<a class="anchor" aria-label="anchor" href="#sec:setting"></a>
</h2>
<p>We consider the problem of a two-stage, two-arm design to establish
superiority of treatment over placebo with respect to the mean
difference. Assume that to that end data
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>Y</mi><mi>j</mi><mrow><mi>g</mi><mo>,</mo><mi>i</mi></mrow></msubsup><annotation encoding="application/x-tex">Y_j^{g, i}</annotation></semantics></math>
is observed for the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>-th
individual of the trial in stage
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false" form="prefix">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">i\in\{1,2\}</annotation></semantics></math>
under treatment
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">g=T</annotation></semantics></math>)
or placebo
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">g=C</annotation></semantics></math>).
Let
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mi>i</mi></msub><annotation encoding="application/x-tex">n_i</annotation></semantics></math>
be the per-group sample size in stage
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and consider the stage-wise test statistics
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><mo>:=</mo><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>i</mi></msub></munderover><msubsup><mi>Y</mi><mi>j</mi><mrow><mi>T</mi><mo>,</mo><mi>i</mi></mrow></msubsup><mo>−</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>i</mi></msub></munderover><msubsup><mi>Y</mi><mi>j</mi><mrow><mi>C</mi><mo>,</mo><mi>i</mi></mrow></msubsup></mrow><mrow><mi>σ</mi><mspace width="0.167em"></mspace><msqrt><mrow><mn>2</mn><mspace width="0.167em"></mspace><msub><mi>n</mi><mi>i</mi></msub></mrow></msqrt></mrow></mfrac></mrow><annotation encoding="application/x-tex">
  X_i := \frac{\sum_{j=1}^{n_i}Y_j^{T,i} - \sum_{j=1}^{n_i}Y_j^{C,i}}{\sigma\,\sqrt{2\,n_i}}
</annotation></semantics></math> for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i=1,2</annotation></semantics></math>.
Under the assumption that the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Y</mi><mi>j</mi><mrow><mi>g</mi><mo>,</mo><mi>i</mi></mrow></msubsup><mover><mo>∼</mo><mrow><mi>i</mi><mi>i</mi><mi>d</mi></mrow></mover><msub><mi>F</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">Y_j^{g, i}\stackrel{iid}{\sim} F_g</annotation></semantics></math>
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐄</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>F</mi><mi>T</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>−</mo><mi>𝐄</mi><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>F</mi><mi>C</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mi>θ</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{E}[F_T] - \boldsymbol{E}[F_C] = \theta</annotation></semantics></math>
and common variance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>σ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\sigma^2</annotation></semantics></math>,
by the central limit theorem, the asymptotic distribution of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>1</mn></msub><annotation encoding="application/x-tex">X_1</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><msqrt><mrow><msub><mi>n</mi><mn>1</mn></msub><mi>/</mi><mn>2</mn></mrow></msqrt><mspace width="0.167em"></mspace><mi>θ</mi><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{N}(\sqrt{n_1/2}\, \theta, 1)</annotation></semantics></math>.
Formally, the null hypothesis for the superiority test is thus
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ℋ</mi><mn>0</mn></msub><mo>:</mo><mi>θ</mi><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathcal{H}_0:\theta\leq 0</annotation></semantics></math>.
Based on the interim outcome
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>1</mn></msub><annotation encoding="application/x-tex">X_1</annotation></semantics></math>,
a decision can be made whether to either stop the trial early for
futility if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>&lt;</mo><msubsup><mi>c</mi><mn>1</mn><mi>f</mi></msubsup></mrow><annotation encoding="application/x-tex">X_1&lt;c_1^f</annotation></semantics></math>,
to stop the trial early for efficacy (early rejection of the null
hypothesis) if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>&gt;</mo><msubsup><mi>c</mi><mn>1</mn><mi>e</mi></msubsup></mrow><annotation encoding="application/x-tex">X_1&gt;c_1^e</annotation></semantics></math>,
or to enter stage two if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><msubsup><mi>c</mi><mn>1</mn><mi>f</mi></msubsup><mo>,</mo><msubsup><mi>c</mi><mn>1</mn><mi>e</mi></msubsup><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">X_1\in[c_1^f, c_1^e]</annotation></semantics></math>.
Conditional on proceeding to a second stage, it holds that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>2</mn></msub><mspace width="0.167em"></mspace><mo stretchy="false" form="prefix">|</mo><mspace width="0.167em"></mspace><msub><mi>X</mi><mn>1</mn></msub><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><msubsup><mi>c</mi><mn>1</mn><mi>f</mi></msubsup><mo>,</mo><msubsup><mi>c</mi><mn>1</mn><mi>e</mi></msubsup><mo stretchy="true" form="postfix">]</mo></mrow><mo>∼</mo><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">(</mo><msqrt><mrow><msub><mi>n</mi><mn>2</mn></msub><mi>/</mi><mn>2</mn></mrow></msqrt><mspace width="0.167em"></mspace><mi>θ</mi><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">X_2\,|\,X_1\in[c_1^f, c_1^e]\sim\mathcal{N}(\sqrt{n_2/2}\, \theta, 1)</annotation></semantics></math>.
In the second stage, the null hypothesis is rejected if and only if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>2</mn></msub><mo>&gt;</mo><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">X_2 &gt; c_2(X_1)</annotation></semantics></math>
for a stage-two critical value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mo>:</mo><msub><mi>x</mi><mn>1</mn></msub><mo>↦</mo><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c_2:x_1\mapsto c_2(x_1)</annotation></semantics></math>.
To test
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℋ</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\mathcal{H}_0</annotation></semantics></math>
at a significance level of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>,
the stage-one critical values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>c</mi><mn>1</mn><mi>f</mi></msubsup><annotation encoding="application/x-tex">c_1^f</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>c</mi><mn>1</mn><mi>e</mi></msubsup><annotation encoding="application/x-tex">c_1^e</annotation></semantics></math>
as well as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c_2(\cdot)</annotation></semantics></math>
must be chosen in a way that protects the overall maximal type one error
rate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>.
Note that it is convenient to define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>∞</mi></mrow><annotation encoding="application/x-tex">c_2(x_1) = \infty</annotation></semantics></math>
if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>&lt;</mo><msubsup><mi>c</mi><mn>1</mn><mi>f</mi></msubsup></mrow><annotation encoding="application/x-tex">x_1&lt;c_1^f</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>−</mo><mi>∞</mi></mrow><annotation encoding="application/x-tex">c_2(x_1) = -\infty</annotation></semantics></math>
if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>&gt;</mo><msubsup><mi>c</mi><mn>1</mn><mi>e</mi></msubsup></mrow><annotation encoding="application/x-tex">x_1&gt;c_1^e</annotation></semantics></math>
since the power curve of the design is then given by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>↦</mo><msub><mrow><mi>𝐏</mi><mi>𝐫</mi></mrow><mi>θ</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">[</mo><msub><mi>X</mi><mn>2</mn></msub><mo>&gt;</mo><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\theta\mapsto\boldsymbol{Pr}_\theta\big[X_2&gt;c_2(X_1)\big]</annotation></semantics></math>.
This results in a classical group-sequential design and several methods
were proposed in the literature for choosing the early-stopping
boundaries
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>c</mi><mn>1</mn><mi>f</mi></msubsup><annotation encoding="application/x-tex">c_1^f</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>c</mi><mn>1</mn><mi>e</mi></msubsup><annotation encoding="application/x-tex">c_1^e</annotation></semantics></math>
(<span class="citation">O’Brien and Fleming (1979)</span>, <span class="citation">Pocock (1977)</span>) and for defining the stage-two
rejection boundary function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c_2(\cdot)</annotation></semantics></math>
(<span class="citation">Bauer and Köhne (1994)</span>, <span class="citation">Hedges and Olkin (1985)</span>). Often, the
inverse-normal combination test <span class="citation">(Lehmacher and
Wassmer 1999)</span> is applied and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c_2(\cdot)</annotation></semantics></math>
is defined as a linear function of the stage-one test-statistic
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mi>c</mi><mo>−</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub></mrow><msub><mi>w</mi><mn>2</mn></msub></mfrac><mi>‚</mi></mrow><annotation encoding="application/x-tex"> 
  c_2(x_1) = \frac{c - w_1 x_1}{w_2}‚
</annotation></semantics></math> for a critical value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
and predefined weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mn>1</mn></msub><annotation encoding="application/x-tex">w_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mn>2</mn></msub><annotation encoding="application/x-tex">w_2</annotation></semantics></math>.
Most commonly, the stage-wise test statistics are weighted in terms of
their respective sample sizes, i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><mo>=</mo><msqrt><mrow><msub><mi>n</mi><mn>1</mn></msub><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msqrt></mrow><annotation encoding="application/x-tex">w_1 = \sqrt{n_1 / (n_1+n_2)}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>2</mn></msub><mo>=</mo><msqrt><mrow><msub><mi>n</mi><mn>2</mn></msub><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msqrt></mrow><annotation encoding="application/x-tex">w_2 = \sqrt{n_2 / (n_1+n_2)}</annotation></semantics></math>.
This choice of the weights is optimal in the sense that it minimizes the
variance of the final test statistic if the assumed sample sizes are
indeed realized <span class="citation">(Zaykin 2011)</span>. Note,
however, that such prespecified weights become inefficient if the sample
size deviates strongly from the anticipated value (cf. <span class="citation">Wassmer and Brannath (2016)</span>, chapter 6.2.5). A
natural extension of this group-sequential framework is to allow the
second stage sample size to also depend on the observed interim outcome,
i.e., to consider a function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub><mo>:</mo><msub><mi>x</mi><mn>1</mn></msub><mo>↦</mo><msub><mi>n</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">n_2:x_1\mapsto n_2(x_1)</annotation></semantics></math>
instead of a fixed value
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mn>2</mn></msub><annotation encoding="application/x-tex">n_2</annotation></semantics></math>.
Such ‘adaptive’ two-stage designs are thus completely characterized by a
five-tuple
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒟</mi><mo>:=</mo><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo>,</mo><msubsup><mi>c</mi><mn>1</mn><mi>f</mi></msubsup><mo>,</mo><msubsup><mi>c</mi><mn>1</mn><mi>e</mi></msubsup><mo>,</mo><msub><mi>n</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{D}:=\big(n_1, c_1^f, c_1^e, n_2(\cdot), c_2(\cdot)\big)</annotation></semantics></math>.</p>
<p>While the required sample size and the critical value for a
single-stage design are uniquely defined by given type one error rate
and power constraints, it is much less clear how the design parameters
of a two-stage design should be selected. This is especially true since
both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mn>2</mn></msub><annotation encoding="application/x-tex">n_2</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mn>2</mn></msub><annotation encoding="application/x-tex">c_2</annotation></semantics></math>
are functions and thus the parameter space is in fact
infinite-dimensional. In order to compare different choices of the
design parameters, appropriate scoring criteria are essential. A widely
applied criterion is the expected sample size under the alternative
hypothesis (see, e.g., <span class="citation">Jennison and Turnbull
(2015)</span>). However, there is a variety of further scoring criteria
that could be incorporated or even combined in order to rate a two-stage
design. For instance, conditional power is defined as the probability to
reject the null hypothesis under the alternative given the interim
result
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">X_1=x_1</annotation></semantics></math>:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>CP</mo><mi>θ</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><msub><mrow><mi>𝐏</mi><mi>𝐫</mi></mrow><mi>θ</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">[</mo><msub><mi>X</mi><mn>2</mn></msub><mo>&gt;</mo><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mspace width="0.167em"></mspace><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">|</mo><mspace width="0.167em"></mspace><msub><mi>X</mi><mn>1</mn></msub><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">]</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">
\operatorname{CP}_\theta(x_1) := \boldsymbol{Pr}_\theta \big[X_2 &gt; c_2(X_1) \, \big| \, X_1=x_1\big].
</annotation></semantics></math> Hence, conditional power is a
conditional score given as the power conditioned on the first-stage
outcome
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">X_1=x_1</annotation></semantics></math>.
<em>Vice versa</em>, power can be seen as an unconditional score that is
obtained by integrating conditional power over all possible stage-one
outcomes, i.e.,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">P</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">e</mi><msub><mi mathvariant="normal">r</mi><mi mathvariant="normal">θ</mi></msub></mrow><mo>=</mo><msub><mi>𝐄</mi><mi>θ</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">[</mo><mo>CP</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">]</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">
\operatorname{Power_\theta} = \boldsymbol{E}_\theta\big[\operatorname{CP}(X_1)\big].
</annotation></semantics></math> Intuitively, it makes sense to require
a minimal conditional power upon continuation to the second stage since
one might otherwise continue a trial with little prospect of still
rejecting the null hypothesis. We demonstrate the consequences of this
heuristic in Section <a href="#sec:CP_constraint">6.4</a>. Once the
scoring criterion is selected, the design parameters may be chosen in
order to optimize this objective. The first ones to address this problem
were <span class="citation">Jennison and Turnbull (2015)</span> who
minimized the expected sample size
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="normal">ESS</mtext><mi>θ</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><msub><mi>𝐄</mi><mi>θ</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">[</mo><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">]</mo><mo>:=</mo><msub><mi>𝐄</mi><mi>θ</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">[</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">
\text{ESS}_{\theta}(\mathcal{D}) := \boldsymbol{E}_{\theta} \big[n(X_1) \big] :=
\boldsymbol{E}_{\theta} \big[n_1 + n_2(X_1) \big]
</annotation></semantics></math> of a two-stage design for given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>,</mo><msubsup><mi>c</mi><mn>1</mn><mi>f</mi></msubsup><mo>,</mo><msubsup><mi>c</mi><mn>1</mn><mi>e</mi></msubsup></mrow><annotation encoding="application/x-tex">n_1,c_1^f, c_1^e</annotation></semantics></math>
with respect to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">n_2(\cdot)</annotation></semantics></math>
for given power and type one error rate constraints. The function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c_2(\cdot)</annotation></semantics></math>,
however, was not optimized. Instead, <span class="citation">Jennison and
Turnbull (2015)</span> used the inverse-normal combination test approach
to derive
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mn>2</mn></msub><annotation encoding="application/x-tex">c_2</annotation></semantics></math>
given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">n_2(\cdot)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mn>1</mn></msub><annotation encoding="application/x-tex">n_1</annotation></semantics></math>.
In <span class="citation">Pilz et al. (2019)</span>, the authors
demonstrated that this restriction is not necessary and that the
variational problem of deriving both functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">n_2(\cdot)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c_2(\cdot)</annotation></semantics></math>
given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>,</mo><msubsup><mi>c</mi><mn>1</mn><mi>f</mi></msubsup><mo>,</mo><msubsup><mi>c</mi><mn>1</mn><mi>e</mi></msubsup></mrow><annotation encoding="application/x-tex">n_1,c_1^f, c_1^e</annotation></semantics></math>
to minimize expected sample size can be solved by analyzing the
corresponding Euler-Lagrange equation. Nesting this step in a standard
optimization over the stage-one parameters allows identifying an optimal
set of all design parameters without imposing parametric assumptions on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c_2(\cdot)</annotation></semantics></math>.
As a result, a fully optimal design
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝒟</mi><mo>*</mo></msup><mo>:=</mo><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msubsup><mi>n</mi><mn>1</mn><mo>*</mo></msubsup><mo>,</mo><msubsup><mi>c</mi><mn>1</mn><mrow><mi>f</mi><mo>,</mo><mo>*</mo></mrow></msubsup><mo>,</mo><msubsup><mi>c</mi><mn>1</mn><mrow><mi>e</mi><mo>,</mo><mo>*</mo></mrow></msubsup><mo>,</mo><msubsup><mi>n</mi><mn>2</mn><mo>*</mo></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><msubsup><mi>c</mi><mn>2</mn><mo>*</mo></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{D}^*:=\big(n_1^*, c_1^{f,*}, c_1^{e, *}, n_2^*(\cdot), c_2^*(\cdot)\big)</annotation></semantics></math>
for the following general optimization problem was derived
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">minimize</mtext></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><msub><mo>ESS</mo><msub><mi>θ</mi><mn>1</mn></msub></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mtext mathvariant="normal">subject to:</mtext></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><msub><mrow><mi>𝐏</mi><mi>𝐫</mi></mrow><msub><mi>θ</mi><mn>0</mn></msub></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">[</mo><msub><mi>X</mi><mn>2</mn></msub><mo>&gt;</mo><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">]</mo></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mo>≤</mo><mi>α</mi><mo>,</mo></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><msub><mrow><mi>𝐏</mi><mi>𝐫</mi></mrow><msub><mi>θ</mi><mn>1</mn></msub></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">[</mo><msub><mi>X</mi><mn>2</mn></msub><mo>&gt;</mo><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">]</mo></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mo>≥</mo><mn>1</mn><mo>−</mo><mi>β</mi></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"></mtd><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}
&amp; \text{minimize} &amp;&amp; \operatorname{ESS}_{\theta_1}(\mathcal{D}) &amp;&amp;&amp;&amp; \\
&amp; \text{subject to:}
&amp;&amp; \boldsymbol{Pr}_{\theta_0}\big[X_2&gt;c_2(X_1)\big] &amp;&amp;\leq \alpha, &amp;&amp;&amp;&amp; \\
&amp;&amp;&amp; \boldsymbol{Pr}_{\theta_1}\big[X_2&gt;c_2(X_1)\big] &amp;&amp;\geq 1-\beta &amp;&amp;&amp;&amp;
\end{align}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta_0=0</annotation></semantics></math>.</p>
</div>
<div class="section level2">
<h2 id="direct-variational-perspective">Direct variational perspective<a class="anchor" aria-label="anchor" href="#direct-variational-perspective"></a>
</h2>
<p>In <strong>adoptr</strong>, a simpler solution strategy than solving
the Euler-Lagrange equation locally is applied to the same problem
class. We propose to embed the entire problem in a finite-dimensional
parameter space and solve the corresponding problem over both stage-one
and stage-two design parameters simultaneously using standard numerical
libraries. I.e., we adopt a <em>direct</em> approach to solving the
variational problem. This is done by defining a discrete set of pivot
points
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mover><mi>x</mi><mo accent="true">̃</mo></mover><mn>1</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo>∈</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>c</mi><mn>1</mn><mi>f</mi></msubsup><mo>,</mo><msubsup><mi>c</mi><mn>1</mn><mi>e</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\widetilde{x}_1^{(i)}\in(c_1^f, c_1^e), i=1,\ldots,k</annotation></semantics></math>,
and interpolating
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>c</mi><mn>2</mn></msub><annotation encoding="application/x-tex">c_2</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mn>2</mn></msub><annotation encoding="application/x-tex">n_2</annotation></semantics></math>
between these pivots. We use cubic Hermite splines <span class="citation">(Fritsch and Carlson 1980)</span> which are
sufficiently flexible, even for a moderate number of pivots, to
approximate any realistic stage-two sample size and critical value
functions. Since the optimal functions are generally very smooth <span class="citation">(Pilz et al. 2019)</span> they are well suited to
spline interpolation. Within the <strong>adoptr</strong> validation
report (cf. Section 7) we investigate empirically the shape of the
approximated functions and that increasing the number of pivots above a
value of 5 to 7 does not improve the optimization results. The latter
implies that a relatively small number of pivot points appears to be
sufficient to obtain valid spline approximations of the optimal
functions. Note that the pivots are only needed in the continuation
region since both functions are (piecewise) constant within the early
stopping regions. In <strong>adoptr</strong>, the pivots are defined as
nodes of a Gaussian quadrature rule of degree
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>.
This choice allows fast and precise numerical integration of any
conditional score over the continuation region, e.g.,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mtext mathvariant="normal">ESS</mtext><mi>θ</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mo>∫</mo><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>f</mi><mi>θ</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>d</mo><msub><mi>x</mi><mn>1</mn></msub><mo>≈</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>ω</mi><mi>i</mi></msub><mspace width="0.167em"></mspace><msub><mi>n</mi><mn>2</mn></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msubsup><mover><mi>x</mi><mo accent="true">̃</mo></mover><mn>1</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><msub><mi>f</mi><mi>θ</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msubsup><mover><mi>x</mi><mo accent="true">̃</mo></mover><mn>1</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} 
\text{ESS}_{\theta}(\mathcal{D})  =
\int n(x_1) f_{\theta} (x_1) \operatorname{d} x_1
\approx n_1 + \sum_{i=1}^{k} \omega_i\, n_2\big(\widetilde{x}_1^{(i)}\big) f_{\theta}
\big(\widetilde{x}_1^{(i)}\big),
\end{align}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>θ</mi></msub><annotation encoding="application/x-tex">f_\theta</annotation></semantics></math>
is the probability density function of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mspace width="0.167em"></mspace><mo stretchy="false" form="prefix">|</mo><mspace width="0.167em"></mspace><mi>θ</mi></mrow><annotation encoding="application/x-tex">X_1\,|\,\theta</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math>
are the corresponding weights of the integration rule. The weights only
depend on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
and the nodes just need to be scaled to the integration interval.
Consequentially, this objective function is smooth in the optimization
parameters and the resulting optimization problem is of dimension
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">2k+3</annotation></semantics></math>,
where the tuning parameters are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msub><mi>n</mi><mn>1</mn></msub><mo>,</mo><msubsup><mi>c</mi><mn>1</mn><mi>f</mi></msubsup><mo>,</mo><msubsup><mi>c</mi><mn>1</mn><mi>e</mi></msubsup><mo>,</mo><msub><mi>n</mi><mn>2</mn></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msubsup><mover><mi>x</mi><mo accent="true">̃</mo></mover><mn>1</mn><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>n</mi><mn>2</mn></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msubsup><mover><mi>x</mi><mo accent="true">̃</mo></mover><mn>1</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>,</mo><msub><mi>c</mi><mn>2</mn></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msubsup><mover><mi>x</mi><mo accent="true">̃</mo></mover><mn>1</mn><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>c</mi><mn>2</mn></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">(</mo><msubsup><mover><mi>x</mi><mo accent="true">̃</mo></mover><mn>1</mn><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow></msubsup><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\big(n_1, c_1^f, c_1^e, n_2\big(\widetilde{x}_1^{(1)}\big),
\dots, n_2\big(\widetilde{x}_1^{(k)}\big), c_2\big(\widetilde{x}_1^{(1)}\big),
\dots, c_2\big(\widetilde{x}_1^{(k)}\big)\big)</annotation></semantics></math>.
Standard numerical solvers may then be employed to minimize it. Since
<strong>adoptr</strong> enables generic objectives (cf. Section <a href="#sec:utility_maximization">6.3</a>), it uses the gradient-free
optimizer COBYLA <span class="citation">(Powell 1994)</span> internally
via the <strong>R</strong>-package <strong>nloptr</strong> (<span class="citation">Johnson (2018)</span>, <span class="citation">Ypma,
Borchers, and Eddelbuettel (2018)</span>).</p>
<p>Most commonly used unconditional performance scores
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">S(\mathcal{D})</annotation></semantics></math>
can be seen as expected values over conditional scores
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">S(\mathcal{D}|X_1)</annotation></semantics></math>
by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>𝐄</mi><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">[</mo><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">S(\mathcal{D}) = \boldsymbol{E}\big[S(\mathcal{D}|X_1)\big]</annotation></semantics></math>
in a similar way as power and expected sample size. Any such ‘integral
score’ can be computed quickly and reliably in <strong>adoptr</strong>
via the choice of pivots outlined above. The correctness of numerically
integrated scores is checked in the <strong>adoptr</strong> validation
report by comparing the numerical integrals to simulated results.</p>
<p>Note that we tacitly relaxed all sample sizes to be real numbers in
the above argument while they are in fact restricted to positive
integers. Integer-valued
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mn>1</mn></msub><annotation encoding="application/x-tex">n_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mn>2</mn></msub><annotation encoding="application/x-tex">n_2</annotation></semantics></math>
would, however, lead to an NP-hard mixed-integer problem. In our
experiments, we found that merely rounding both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mn>1</mn></msub><annotation encoding="application/x-tex">n_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mn>2</mn></msub><annotation encoding="application/x-tex">n_2</annotation></semantics></math>
after the optimization works fine. The extensive validation suite
(cf. Section 7) evaluates by numerical integration and simulation
whether the included constraints are fulfilled for optimal designs with
rounded sample sizes. Up to now, neither the constraints were violated
nor an efficiency loss with respect to the underlying objective function
was observed. In theory, one could re-adjust the decision boundaries for
these rounded sample sizes, but we failed to see any practical benefit
from this, even for small trials where the rounding error is largest
(data not shown).</p>
</div>
<div class="section level2">
<h2 id="the-need-for-an-r-package">The need for an R package<a class="anchor" aria-label="anchor" href="#the-need-for-an-r-package"></a>
</h2>
<p><span class="citation">Bauer et al. (2015)</span> state that adequate
statistical software for adaptive designs ‘is increasingly needed to
evaluate the adaptations and to find reasonable strategies’.</p>
<p>Commercial software such as JMP <span class="citation">(SAS Institute
Inc., n.d.a)</span> or Minitab <span class="citation">(Minitab, Inc.
2020)</span> allow planning and analyzing a wide range of experimental
setups. Amongst others, they provide tools for randomization,
stratification, block-building, or D-optimal designs. These general
purpose statistical software packages do not, however, allow planning of
more specialized multi-stage designs encountered in clinical trials. For
group-sequential designs, some planning capabilities are available in
the <strong>SAS</strong> procedure <code>seqdesign</code> <span class="citation">(SAS Institute Inc., n.d.b)</span>, PASS <span class="citation">(NCSS 2019)</span>, or ADDPLAN <span class="citation">(ICON plc 2020)</span>. East <span class="citation">(Cytel 2020)</span> also supports design, simulation
and analysis of experiments with interim analyses. The East ADAPT and
the East SURVADAPT modules support sample size recalculation.
Furthermore, there are various open-source <strong>R</strong>-packages
for the analysis of multi-stage designs. The package
<strong>adaptTest</strong> <span class="citation">(Vandemeulebroecke
2009)</span> implements combination tests for adaptive two-stage
designs. <strong>AGSDest</strong> <span class="citation">(Hack,
Brannath, and Brueckner 2019)</span> allows estimation and computation
of confidence intervals in adaptive group-sequential designs. More
detailed overviews on software for adaptive clinical trial designs can
be found in <span class="citation">Bauer et al. (2015)</span>, chapter
6, or in <span class="citation">Tymofyeyev (2014)</span>. The choice of
software for optimally designing two- or multi-stage designs, however,
is much more limited. Current <strong>R</strong>-packages concerned with
optimal clinical trial designs are <strong>OptGS</strong> (<span class="citation">Wason and Burkardt (2015)</span>, <span class="citation">Wason (2015)</span>) and <strong>rpact</strong> <span class="citation">(Wassmer and Pahlke 2019)</span>. These are, however,
exclusively focused on group-sequential designs and lack the ability to
specify custom objective functions and constraints.</p>
<p>The lack of flexibility in formulating the objective function and
constraints might lead to off-the-shelf solutions not entirely
reflecting the needs of a particular trial consequentially resulting in
inefficient designs. The <strong>R</strong>-package
<strong>adoptr</strong> aims at providing a simple and interactive yet
flexible interface for addressing a range of optimization problems
encountered with two-stage one- or two-arm clinical trials. In
particular, <strong>adoptr</strong> allows to model <em>a priori</em>
uncertainty over
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
via prior distributions and thus supports optimization under uncertainty
(cf. Section <a href="#sec:uncertainty">6.2</a>).
<strong>adoptr</strong> also supports the combination of conditional (on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mn>1</mn></msub><annotation encoding="application/x-tex">X_1</annotation></semantics></math>)
and unconditional scores and constraints to address concerns such as
type-one-error-rate control (unconditional score) and, e.g., a minimal
conditional power (conditional score) simultaneously (cf. Section <a href="#sec:utility_maximization">6.3</a>). To facilitate the adoption of
these advanced trial designs in the clinical trials community,
<strong>adoptr</strong> also features an extensive test and validation
suite (cf. Section 7).</p>
<p>In the following, we outline the key design principles for
<strong>adoptr</strong>.</p>
<ol style="list-style-type: decimal">
<li>
<strong>Interactivity:</strong> A major advantage of the
<strong>R</strong>-programming language is its powerful metaprogramming
capabilities and flexible class system. With a combination of
non-standard evaluation and S4 classes, we hope to achieve a structured
and modular way of expressing optimization problems in clinical trials
that integrates nicely with an interactive workflow. We feel that a
step-wise problem formulation via the creation of modular intermediate
objects, which can be explored and modified separately, encourages
exploration of different options.</li>
<li>
<strong>Reliability:</strong> A crux in open-source software
development for clinical trials is achieving demonstrable validation.
Potential users need to be convinced of the software quality and need to
be able to comply with their respective validation requirements which
often require the ability to produce a validation report. This burden
typically results in innovative software not being used at all - simply
because the validation effort cannot be stemmed. We address this issue
with an extensive unit test suite and a companion validation report
(cf. Section 7).</li>
<li>
<strong>Extensibility:</strong> We do not want to impose a
particular choice of scores or constraints or promote a particular
notion of optimality for clinical trial designs. In cases where the
composition of existing scores is not sufficient, the object-oriented
approach of <strong>adoptr</strong> facilitates the definition of custom
scores and constraints that seamlessly integrate with the remainder of
the package.</li>
</ol>
</div>
<div class="section level2">
<h2 id="sec:structure">Adoptr’s structure<a class="anchor" aria-label="anchor" href="#sec:structure"></a>
</h2>
<p>The package <strong>adoptr</strong> is based on <strong>R</strong>’s
S4 class system. This allows to use multiple dispatch on the classes of
multiple arguments to a method. In this section, the central components
of <strong>adoptr</strong> are described briefly. The following figure
gives a structural overview of the main classes in
<strong>adoptr</strong>.</p>
<p>To compute optimal designs, an object of class
<code>UnconditionalScore</code> must be defined as objective criterion.
<strong>adoptr</strong> distinguishes between
<code>ConditionalScore</code>s and <code>UnconditionalScore</code>s
(cf. Section <a href="#sec:setting">2</a>). All <code>Score</code>s can
be evaluated using the method <code>evaluate</code>. For unconditional
scores, this method only requires a <code>Score</code> object and a
<code>TwoStageDesign</code> object, for conditional scores (like
conditional power), it also requires the interim outcome
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>1</mn></msub><annotation encoding="application/x-tex">x_1</annotation></semantics></math>.
Note that any <code>ConditionalScore</code>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mn>1</mn></msub><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">S(\mathcal{D}|X_1=x_1)</annotation></semantics></math>
can be converted to an <code>UnconditionalScore</code>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>𝐄</mi><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">[</mo><mi>S</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="false" form="prefix">|</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">S(\mathcal{D}) = \boldsymbol{E}\big[S(\mathcal{D}|X_1)\big]</annotation></semantics></math>
using the method <code>expected</code>. The two most widely used
conditional scores are pre-implemented as <code>ConditionalPower</code>
and <code>ConditionalSampleSize</code>. Their unconditional counterparts
are <code>Power</code> and <code>ExpectedSampleSize</code>. Further
predefined unconditional scores are <code>MaximumSampleSize</code>,
evaluating the maximum sample size, <code>N1</code>, measuring the
first-stage sample size, and <code>AverageN2</code>, evaluating the
average of the stage-two sample size (improper prior). These scores may
be used for regularization if variable stage-two sample sizes or a high
stage-one sample size are to be penalized. Users are free to define
their own <code>Score</code>s (cf. the vignette ‘Defining New Scores’
<span class="citation">(Kunzmann and Pilz 2020)</span>). Moreover,
different <code>Score</code>s can be composed to a single one by the
function <code>composite</code> (cf. Section <a href="#sec:utility_maximization">6.3</a>). Both conditional and
unconditional scores can also be used to define constraints - the most
common case being constraints for power and maximal type one error rate.
The function <code>minimize</code> takes an unconditional score as
objective and a set of constraints and optimizes the design
parameters.</p>
<p>In <strong>adoptr</strong>, different kinds of designs are
implemented. The most frequently applied case is a
<code>TwoStageDesign</code>, i.e., a design with one interim analysis
and a sample size function that varies with the interim test statistic.
Another option is the subclass <code>GroupSequentialDesign</code> which
restricts the sample size function on the continuation region to a
single number, i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mspace width="0.222em"></mspace><mo>∀</mo><msub><mi>x</mi><mn>1</mn></msub><mo>∈</mo><mrow><mo stretchy="true" form="prefix">[</mo><mspace width="0.167em"></mspace><msubsup><mi>c</mi><mn>1</mn><mi>f</mi></msubsup><mo>,</mo><msubsup><mi>c</mi><mn>1</mn><mi>e</mi></msubsup><mspace width="0.167em"></mspace><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">{n_2(x_1) = n_2\ \forall x_1\in[\,c_1^f, c_1^e\,]}</annotation></semantics></math>.
Additionally, <strong>adoptr</strong> supports the computation of
optimal <code>OneStageDesign</code>s, i.e., designs without an interim
analysis. Technically, one-stage designs are implemented as subclasses
of <code>TwoStageDesign</code> since they can be viewed as the limiting
case for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub><mo>≡</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n_2\equiv0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>c</mi><mn>1</mn><mi>f</mi></msubsup><mo>=</mo><msubsup><mi>c</mi><mn>1</mn><mi>e</mi></msubsup></mrow><annotation encoding="application/x-tex">c_1^f=c_1^e</annotation></semantics></math>.
Hence, all methods that are implemented for <code>TwoStageDesign</code>s
also work for <code>GroupSequentialDesign</code>s and
<code>OneStageDesign</code>s. Users can chose to keep some elements of a
design fixed during optimization using the methods
<code>make_fixed</code> (cf. Section <a href="#sec:make_fixed">6.5</a>).</p>
<p>The joint data distribution in <strong>adoptr</strong> consists of
two elements. The distribution of the test statistic is specified by an
object of class <code>DataDistribution</code>. Currently, the three
options <code>Normal</code>, <code>Binomial</code>, and
<code>Student</code> are implemented. The logical variable
<code>two_armed</code> allows the differentiation between one- and
two-armed trials. Furthermore, <strong>adoptr</strong> supports prior
distributions on the effect size. These can be
<code>PointMassPrior</code>s (cf. Section <a href="#sec:standard_case">6.1</a>) as well as
<code>ContinuousPrior</code>s (cf. Section <a href="#sec:uncertainty">6.2</a>).</p>
<p>In the following section, more hands on examples demonstrate the
capabilities of <strong>adoptr</strong> and its syntax.</p>
</div>
<div class="section level2">
<h2 id="sec:Examples">Examples<a class="anchor" aria-label="anchor" href="#sec:Examples"></a>
</h2>
<div class="section level3">
<h3 id="sec:standard_case">Standard case<a class="anchor" aria-label="anchor" href="#sec:standard_case"></a>
</h3>
<p>Consider the case of a randomized controlled clinical trial where
efficacy is to be demonstrated in terms of superiority of the treatment
over placebo with respect to the population mean difference
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
of an outcome. Let the null hypothesis be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ℋ</mi><mn>0</mn></msub><mo>:</mo><mi>θ</mi><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\mathcal{H}_0:\theta\leq 0</annotation></semantics></math>.
Assume that the maximal type one error rate is to be controlled at a
one-sided level
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>2.5</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">\alpha=2.5\%</annotation></semantics></math>
and a minimal power of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>90</mn><mi>%</mi></mrow><annotation encoding="application/x-tex">90\%</annotation></semantics></math>
at a point alternative of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub><mo>=</mo><mn>0.3</mn></mrow><annotation encoding="application/x-tex">\theta_1=0.3</annotation></semantics></math>
is deemed necessary. For simplicity’s sake, we assume
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>σ</mi><mn>2</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sigma^2=1</annotation></semantics></math>
without loss of generality. The required sample size for a one-stage
design with analysis by the one-sided two-sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>-test
would then be roughly 235 per group.</p>
<p>Using <strong>adoptr</strong>, the two-stage design minimizing the
expected sample size under the alternative hypothesis can be derived for
the very same situation. First, the data distribution is specified to be
normal. The <code>two_armed</code> parameter allows to switch between
single-armed and two-armed trials.</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="va">datadist</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/NormalDataDistribution-class.html">Normal</a></span><span class="op">(</span>two_armed <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre>
<p>In this example, we use simple point priors for both the null and
alternative hypotheses. The hypotheses and the corresponding scores
(power values) can be specified as:</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="va">null</span>        <span class="op">&lt;-</span> <span class="fu"><a href="../reference/PointMassPrior-class.html">PointMassPrior</a></span><span class="op">(</span>theta <span class="op">=</span> <span class="fl">.0</span>, mass <span class="op">=</span> <span class="fl">1.0</span><span class="op">)</span></span>
<span><span class="va">R</span><span class="op">&gt;</span> <span class="va">alternative</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/PointMassPrior-class.html">PointMassPrior</a></span><span class="op">(</span>theta <span class="op">=</span> <span class="fl">.3</span>, mass <span class="op">=</span> <span class="fl">1.0</span><span class="op">)</span></span>
<span><span class="va">R</span><span class="op">&gt;</span> <span class="va">power</span>       <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ConditionalPower-class.html">Power</a></span><span class="op">(</span>dist <span class="op">=</span> <span class="va">datadist</span>, prior <span class="op">=</span> <span class="va">alternative</span><span class="op">)</span></span>
<span><span class="va">R</span><span class="op">&gt;</span> <span class="va">toer</span>        <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ConditionalPower-class.html">Power</a></span><span class="op">(</span>dist <span class="op">=</span> <span class="va">datadist</span>, prior <span class="op">=</span> <span class="va">null</span><span class="op">)</span></span>
<span><span class="va">R</span><span class="op">&gt;</span> <span class="va">mss</span>         <span class="op">&lt;-</span> <span class="fu"><a href="../reference/MaximumSampleSize-class.html">MaximumSampleSize</a></span><span class="op">(</span><span class="op">)</span></span></code></pre>
<p>A <code>Power</code> score requires the data distribution and the
prior to be specified. For this example, we choose
<code>PointMassPrior</code>s with the entire probability mass of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
on a single point, the null hypothesis
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta = 0</annotation></semantics></math>
to compute the type one error rate, and the alternative hypothesis
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mn>0.3</mn></mrow><annotation encoding="application/x-tex">\theta = 0.3</annotation></semantics></math>
to compute the power. The objective function is the expected sample size
under the alternative.</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="va">ess</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ConditionalSampleSize-class.html">ExpectedSampleSize</a></span><span class="op">(</span>dist <span class="op">=</span> <span class="va">datadist</span>, prior <span class="op">=</span> <span class="va">alternative</span><span class="op">)</span></span></code></pre>
<p>Since <strong>adoptr</strong> internally relies on the COBYLA
implementation of <strong>nloptr</strong>, an initial design is
required. A heuristic initial choice is provided by the function
<code>get_initial_design</code>. It is based on a fixed design that
fulfills constraints on type one error rate and power. The type of the
design (two-stage, group-sequential, or one-stage) and the data
distribution have to be defined. For the Gaussian quadrature used during
optimization, one also has to specify the order of the integration rule,
i.e., the number of pivot points between early stopping for futility and
early stopping for efficacy. In practice, order 7 turned out to be
sufficiently flexible to obtain valid results (data not shown).</p>
<pre class="text"><code>R&gt; initial_design &lt;- get_initial_design(theta = 0.3, alpha = 0.025,
+                                       beta = 0.1, type = "two-stage",
+                                       dist = datadist, order = 7)</code></pre>
<p>It is easy to check that the initial design does not fulfill any of
the constraints (minimal power of 90% and maximal type one error rate of
2.5%) with equality by evaluating the respective scores:</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="fu"><a href="../reference/Scores.html">evaluate</a></span><span class="op">(</span><span class="va">toer</span>, <span class="va">initial_design</span><span class="op">)</span></span>
<span><span class="va">R</span><span class="op">&gt;</span> <span class="fu"><a href="../reference/Scores.html">evaluate</a></span><span class="op">(</span><span class="va">power</span>, <span class="va">initial_design</span><span class="op">)</span></span></code></pre>
<p>Alternatively, one might also <code>evaluate</code> a constraint
object directly via</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="fu"><a href="../reference/Scores.html">evaluate</a></span><span class="op">(</span><span class="va">toer</span>  <span class="op">&lt;=</span> <span class="fl">.025</span>, <span class="va">initial_design</span><span class="op">)</span></span>
<span><span class="va">R</span><span class="op">&gt;</span> <span class="fu"><a href="../reference/Scores.html">evaluate</a></span><span class="op">(</span><span class="va">power</span> <span class="op">&gt;=</span> <span class="fl">.9</span>, <span class="va">initial_design</span><span class="op">)</span></span></code></pre>
<p>All constraint objects are normalized to the form
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">h(\mathcal{D}) \leq 0</annotation></semantics></math>
(unconditional) or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo>,</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">h(\mathcal{D}, x_1) \leq 0</annotation></semantics></math>
(conditional on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">X_1=x_1</annotation></semantics></math>).
Calling <code>evaluate</code> on a constraint object then simply returns
the left-hand side of the inequality. The actual optimization is started
by invoking <code>minimize</code></p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="va">opt1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/minimize.html">minimize</a></span><span class="op">(</span><span class="va">ess</span>, <span class="fu"><a href="../reference/subject_to.html">subject_to</a></span><span class="op">(</span><span class="va">power</span> <span class="op">&gt;=</span> <span class="fl">0.9</span>, <span class="va">toer</span>  <span class="op">&lt;=</span> <span class="fl">0.025</span><span class="op">)</span>,</span>
<span><span class="op">+</span>                   <span class="va">initial_design</span><span class="op">)</span></span></code></pre>
<p>The modular structure of the problem specification is intended to
facilitate the inspection or modification of individual components. The
call to <code><a href="../reference/minimize.html">minimize()</a></code> is designed to be as close as possible
to the mathematical formulation of the optimization problem and returns
both the optimized design (<code>opt1$design</code>) as well as the full
<strong>nloptr</strong> return value with details on the optimization
procedure (<code>opt1$nloptr_return</code>).</p>
<p>A <code>summary</code> method for objects of the class
<code>TwoStageDesign</code> is available to quickly evaluate a set of
<code>ConditionalScores</code> such as conditional power as well as
<code>UnconditionalScores</code> such as power and expected sample
size.</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="va">cp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ConditionalPower-class.html">ConditionalPower</a></span><span class="op">(</span>dist <span class="op">=</span> <span class="va">datadist</span>, prior <span class="op">=</span> <span class="va">alternative</span><span class="op">)</span></span>
<span><span class="va">R</span><span class="op">&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">opt1</span><span class="op">$</span><span class="va">design</span>, <span class="st">"Power"</span> <span class="op">=</span> <span class="va">power</span>, <span class="st">"ESS"</span> <span class="op">=</span> <span class="va">ess</span>, <span class="st">"CP"</span> <span class="op">=</span> <span class="va">cp</span><span class="op">)</span></span></code></pre>
<p><strong>adoptr</strong> also implements a default plot method for the
overall sample size and the stage-two critical value as functions of the
first-stage test statistic
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>1</mn></msub><annotation encoding="application/x-tex">x_1</annotation></semantics></math>.
The plot method also accepts additional <code>ConditionalScores</code>
such as conditional power. Calling the plot method produces several
plots with the interim test statistic
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>1</mn></msub><annotation encoding="application/x-tex">x_1</annotation></semantics></math>
on the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>-axis
and the respective function on the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>-axis.</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">opt1</span><span class="op">$</span><span class="va">design</span>, `Conditional power` <span class="op">=</span> <span class="va">cp</span><span class="op">)</span></span></code></pre>
<p>Note the slightly bent shape of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c_2(\cdot)</annotation></semantics></math>
function. For two-stage designs based on the inverse-normal combination
function,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c_2(\cdot)</annotation></semantics></math>
would be linear by definition. Since the optimal shape of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c_2(\cdot)</annotation></semantics></math>
is not linear (but almost), inverse-normal combination methods are
slightly less efficient (cf. <span class="citation">Pilz et al.
(2019)</span> for a more detailed discussion of this issue).</p>
</div>
<div class="section level3">
<h3 id="sec:uncertainty">Optimization under uncertainty<a class="anchor" aria-label="anchor" href="#sec:uncertainty"></a>
</h3>
<p><strong>adoptr</strong> is not limited to point priors but also
supports arbitrary continuous prior distributions. Consider the same
situation as before but now assume that the prior over the effect size
is given by a much more realistic truncated normal distribution with
mean
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.3</mn><annotation encoding="application/x-tex">0.3</annotation></semantics></math>
and standard deviation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.1</mn><annotation encoding="application/x-tex">0.1</annotation></semantics></math>,
i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>∼</mo><msub><mi>𝒩</mi><mrow><mo stretchy="true" form="prefix">[</mo><mo>−</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><mn>0.3</mn><mo>,</mo><msup><mn>0.1</mn><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\theta\sim\mathcal{N}_{[-1, 1]}(0.3, 0.1^2)</annotation></semantics></math>.
The order of integration is set to 25 to obtain precise results.</p>
<pre class="text"><code>R&gt; prior &lt;- ContinuousPrior(
+    pdf     = function(theta) dnorm(theta, mean = .3, sd = .1),
+    support = c(-1, 1),
+    order   = 25)</code></pre>
<p>The objective function is the expected sample size under the
prior</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="va">ess</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ConditionalSampleSize-class.html">ExpectedSampleSize</a></span><span class="op">(</span>dist <span class="op">=</span> <span class="va">datadist</span>, prior <span class="op">=</span> <span class="va">prior</span><span class="op">)</span></span></code></pre>
<p>and we replace power with expected power
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐄</mi><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">[</mo><msub><mrow><mi>𝐏</mi><mi>𝐫</mi></mrow><mi>θ</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">[</mo><msub><mi>X</mi><mn>2</mn></msub><mo>&gt;</mo><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">]</mo><mspace width="0.167em"></mspace><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">|</mo><mspace width="0.167em"></mspace><mi>θ</mi><mo>≥</mo><mn>0.1</mn><mo minsize="1.8" maxsize="1.8" stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">
\boldsymbol{E} \Big[
\boldsymbol{Pr}_\theta\big[X_2&gt;c_2(X_1)\big] \, \Big| \, \theta \geq 0.1 \Big]
</annotation></semantics></math> which is the expected power given a
relevant effect (here we define the minimal relevant effect as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.1</mn><annotation encoding="application/x-tex">0.1</annotation></semantics></math>).
This score can be defined in <strong>adoptr</strong> by first
conditioning the prior.</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="va">epower</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ConditionalPower-class.html">Power</a></span><span class="op">(</span>dist <span class="op">=</span> <span class="va">datadist</span>, prior <span class="op">=</span> <span class="fu"><a href="../reference/condition.html">condition</a></span><span class="op">(</span><span class="va">prior</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">.1</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre>
<p>The optimal design under the point prior only achieves an expected
power of</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="fu"><a href="../reference/Scores.html">evaluate</a></span><span class="op">(</span><span class="va">epower</span>, <span class="va">opt1</span><span class="op">$</span><span class="va">design</span><span class="op">)</span></span></code></pre>
<p>The optimal design under the truncated normal prior fulfilling the
expected power constraint is then given by</p>
<pre class="text"><code>R&gt; opt2 &lt;- minimize(ess, subject_to(epower &gt;= 0.9, toer &lt;= 0.025),
+                   initial_design,
+                   opts = list(algorithm = "NLOPT_LN_COBYLA",
+                               xtol_rel = 1e-5, maxeval = 20000))</code></pre>
<p>Note that the increased complexity of the problem requires a larger
maximal number of iterations for the underlying optimization procedure.
<strong>adoptr</strong> exposes the <strong>nloptr</strong> options via
the argument <code>opts</code>. In cases where the maximal number of
iterations is exhausted, a warning is thrown.</p>
<p>The expected sample size under the prior of the obtained optimal
design equals . This shows that an increased uncertainty on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>
requires larger sample sizes to fulfill the expected power constraint
since the expected sample size under the continuous prior considered in
this section of the optimal design derived under a point alternative
(see Section <a href="#sec:standard_case">6.1</a>) is only .</p>
</div>
<div class="section level3">
<h3 id="sec:utility_maximization">Utility maximization and composite scores<a class="anchor" aria-label="anchor" href="#sec:utility_maximization"></a>
</h3>
<p><strong>adoptr</strong> also supports composite scores. This can be
used to derive utility maximizing designs by defining an objective
function combining both expected power and expected sample size instead
of imposing a hard constraint on expected power. For example, in the
above situation one could be interested in a utility-maximizing design.
Here, we consider the utility function
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>:=</mo><mn>200000</mn><mspace width="0.167em"></mspace><mi>𝐄</mi><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">[</mo><msub><mrow><mi>𝐏</mi><mi>𝐫</mi></mrow><mi>θ</mi></msub><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">[</mo><msub><mi>X</mi><mn>2</mn></msub><mo>&gt;</mo><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">]</mo><mspace width="0.167em"></mspace><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">|</mo><mspace width="0.167em"></mspace><mi>θ</mi><mo>≥</mo><mn>0.1</mn><mo minsize="1.8" maxsize="1.8" stretchy="false" form="postfix">]</mo><mo>−</mo><mi>𝐄</mi><mo minsize="1.8" maxsize="1.8" stretchy="false" form="prefix">[</mo><mi>n</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo minsize="1.8" maxsize="1.8" stretchy="false" form="postfix">]</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">
u(\mathcal{D}) := 200000\, \boldsymbol{E} \Big[
\boldsymbol{Pr}_\theta\big[X_2&gt;c_2(X_1)\big] \, \Big| \, \theta \geq 0.1 \Big] - \boldsymbol{E}\Big[n(X_1)^2\Big],
</annotation></semantics></math> thus allowing a direct trade-off
between power and sample size. Here, the expected sample size is chosen
because the practitioner might prefer flatter sample size curves. This
can be achieved with expected squared sample size by penalizing large
sample sizes stronger than low sample sizes. Furthermore, there is no
longer a strict expected power constraint but the expected power becomes
part of the utility function which allows a direct trade-off between the
two quantities. This can be interpreted as a pricing mechanism (cf.
<span class="citation">Kunzmann and Kieser (2020)</span>): Every
additional percent point of expected power has a (positive) value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>$</mi><mn>2</mn><mi>′</mi><mn>000</mn></mrow><annotation encoding="application/x-tex">\$ 2'000</annotation></semantics></math>
while an increase of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐄</mi><mo minsize="1.2" maxsize="1.2" stretchy="false" form="prefix">[</mo><mi>n</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo minsize="1.2" maxsize="1.2" stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\boldsymbol{E}\big[n(X_1)^2\big]</annotation></semantics></math>
by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
incurs costs of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>$</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">\$ 1</annotation></semantics></math>.
The goal is then to compute the design which is maximizing the overall
utility defined by the utility function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">u(\mathcal{D})</annotation></semantics></math>
(or equivalently minimize costs).</p>
<p>A composite score can be defined via any valid numerical
<strong>R</strong> expression of score objects. We start by defining a
score for the expected quadratic sample size</p>
<pre class="text"><code>R&gt; `n(X_1)`      &lt;- ConditionalSampleSize()
R&gt; `E[n(X_1)^2]` &lt;- expected(composite({`n(X_1)`^2}),
+                            data_distribution = datadist,
+                            prior = prior)</code></pre>
<p>before minimizing the corresponding negative utility without a hard
expected power constraint.</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="va">opt3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/minimize.html">minimize</a></span><span class="op">(</span><span class="fu"><a href="../reference/composite.html">composite</a></span><span class="op">(</span><span class="op">{</span><span class="va">`E[n(X_1)^2]`</span> <span class="op">-</span> <span class="fl">200000</span><span class="op">*</span><span class="va">epower</span><span class="op">}</span><span class="op">)</span>,</span>
<span><span class="op">+</span>                   <span class="fu"><a href="../reference/subject_to.html">subject_to</a></span><span class="op">(</span><span class="va">toer</span> <span class="op">&lt;=</span> <span class="fl">0.025</span><span class="op">)</span>, <span class="va">initial_design</span><span class="op">)</span></span></code></pre>
<p>The expected power of the design is</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="fu"><a href="../reference/Scores.html">evaluate</a></span><span class="op">(</span><span class="va">epower</span>, <span class="va">opt3</span><span class="op">$</span><span class="va">design</span><span class="op">)</span></span></code></pre>
<p>The three optimal designs which have been computed so far are
depicted in a joint plot. The design using the continuous prior requires
higher sample sizes due to the higher uncertainty about
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>θ</mi><annotation encoding="application/x-tex">\theta</annotation></semantics></math>.
The utility maximization approach results in similar shapes of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">n(\cdot)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mo>⋅</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">c_2(\cdot)</annotation></semantics></math>
as the constraint optimization. However, the sample sizes are lower due
to the design’s lower power which is only possible by allowing a
trade-off between expected power and expected sample size. In
particular, the maximal sample size of the utility-based design equals
and is distinctly smaller than in the case of a hard power constraint
under a point prior (maximal sample size: ) or a continuous prior
(maximal sample size: ).</p>
</div>
<div class="section level3">
<h3 id="sec:CP_constraint">Conditional power constraint<a class="anchor" aria-label="anchor" href="#sec:CP_constraint"></a>
</h3>
<p><strong>adoptr</strong> also allows the incorporation of hard
constraints on conditional scores such as conditional power. Conditional
power constraints are intuitively sensible to make sure that a trial
which continues to the second stage maintains a high chance of rejecting
the null hypothesis at the end. For this example, we return to the case
of a point prior on the effect size.</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="va">prior</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/PointMassPrior-class.html">PointMassPrior</a></span><span class="op">(</span>theta <span class="op">=</span> <span class="fl">.3</span>, mass <span class="op">=</span> <span class="fl">1.0</span><span class="op">)</span></span>
<span><span class="va">R</span><span class="op">&gt;</span> <span class="va">ess</span>   <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ConditionalSampleSize-class.html">ExpectedSampleSize</a></span><span class="op">(</span>dist <span class="op">=</span> <span class="va">datadist</span>, prior <span class="op">=</span> <span class="va">prior</span><span class="op">)</span></span>
<span><span class="va">R</span><span class="op">&gt;</span> <span class="va">cp</span>    <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ConditionalPower-class.html">ConditionalPower</a></span><span class="op">(</span>dist <span class="op">=</span> <span class="va">datadist</span>, prior <span class="op">=</span> <span class="va">prior</span><span class="op">)</span></span>
<span><span class="va">R</span><span class="op">&gt;</span> <span class="va">power</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/Scores.html">expected</a></span><span class="op">(</span><span class="va">cp</span>, data_distribution <span class="op">=</span> <span class="va">datadist</span>, prior <span class="op">=</span> <span class="va">prior</span><span class="op">)</span></span></code></pre>
<p>Here, power is derived as expected score of the corresponding
conditional power. A conditional power constraint is added in exactly
the same way as unconditional constraints.</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="va">opt4</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/minimize.html">minimize</a></span><span class="op">(</span><span class="va">ess</span>, <span class="fu"><a href="../reference/subject_to.html">subject_to</a></span><span class="op">(</span><span class="va">toer</span> <span class="op">&lt;=</span> <span class="fl">0.025</span>, <span class="va">power</span> <span class="op">&gt;=</span> <span class="fl">0.9</span>, <span class="va">cp</span> <span class="op">&gt;=</span> <span class="fl">0.8</span><span class="op">)</span>,</span>
<span><span class="op">+</span>                   <span class="va">initial_design</span><span class="op">)</span></span></code></pre>
<p>Comparing the optimal design that has been computed here with the
same constraints but without a conditional power constraint
(cf. beginning of this chapter), the optimal design with the additional
constraint requires larger sample sizes in regions where the conditional
power would usually be below the given threshold. Overall, the
additional constraint reduces the feasible solution space and
consequently increases the expected sample size ( with conditional power
constraint vs. without). This example demonstrates, that any additional
binding conditional constraints do come at costs for global optimality.
Whether or not the loss in unconditional performance is outweighed by
more appealing conditional properties must be decided on a case by case
basis.</p>
</div>
<div class="section level3">
<h3 id="sec:make_fixed">Keeping design parameters fixed<a class="anchor" aria-label="anchor" href="#sec:make_fixed"></a>
</h3>
<p>In clinical practice, non-statistical considerations may impose
direct constraints on design parameters. For instance, a sponsor might
be subject to logistical constraints that render it necessary to design
a trial with a specific stage one sample size. Returning to the standard
case discussed in Section <a href="#sec:standard_case">6.1</a>, assume
that a stage-one per-group sample size of exactly 80 individuals per
group is required
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo>=</mo><mn>80</mn></mrow><annotation encoding="application/x-tex">n_1 = 80</annotation></semantics></math>)
instead of the optimal value of $n_1^* = $. Furthermore, assume that the
sponsor wants to stop early for futility if and only if there is a
negative effect size at the interim analysis, i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>c</mi><mn>1</mn><mi>f</mi></msubsup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c_1^f = 0</annotation></semantics></math>.
<strong>adoptr</strong> supports such considerations by allowing to fix
specific values of a design:</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="va">initial_design</span><span class="op">@</span><span class="va">n1</span>  <span class="op">&lt;-</span> <span class="fl">80</span></span>
<span><span class="va">R</span><span class="op">&gt;</span> <span class="va">initial_design</span><span class="op">@</span><span class="va">c1f</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span><span class="va">R</span><span class="op">&gt;</span> <span class="va">initial_design</span>     <span class="op">&lt;-</span> <span class="fu"><a href="../reference/make_tunable.html">make_fixed</a></span><span class="op">(</span><span class="va">initial_design</span>, <span class="va">n1</span>, <span class="va">c1f</span><span class="op">)</span></span></code></pre>
<p>Any ‘fixed’ parameter will be kept constant during optimization. Note
that it is also possible to ‘un-fix’ parameters again using the
<code>make_tunable</code> function.</p>
<pre class="text"><code><span><span class="va">R</span><span class="op">&gt;</span> <span class="va">opt5</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/minimize.html">minimize</a></span><span class="op">(</span><span class="va">ess</span>, <span class="fu"><a href="../reference/subject_to.html">subject_to</a></span><span class="op">(</span><span class="va">toer</span> <span class="op">&lt;=</span> <span class="fl">0.025</span>, <span class="va">power</span> <span class="op">&gt;=</span> <span class="fl">0.9</span><span class="op">)</span>,</span>
<span><span class="op">+</span>                   <span class="va">initial_design</span><span class="op">)</span></span></code></pre>
<p>The following figure visually compares the original design with the
new, more restricted design. The designs are qualitatively similar, but
fixing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>n</mi><mn>1</mn></msub><annotation encoding="application/x-tex">n_1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>c</mi><mn>1</mn><mi>f</mi></msubsup><annotation encoding="application/x-tex">c_1^f</annotation></semantics></math>
does come at the price of slightly increased expected sample size (
compared to in the less restricted case).</p>
</div>
</div>
<div class="section level2">
<h2 id="sec:validation">Validation concept<a class="anchor" aria-label="anchor" href="#sec:validation"></a>
</h2>
<p>The conduct and analysis of clinical trials is a highly regulated
process. An essential requirement being put forward in Title 21 CRF
(code of federal regulations) Part 11 is the need to validate any
software used to work with or produce records <span class="citation">(US
Food and Drug Administration and others 2003)</span>. The exact scope of
regulations such as CRF 11 is sometimes difficult to assess, and it is
not always clear which regulations apply to <strong>R</strong> packages
used in a production environment <span class="citation">(The R
Foundation for Statistical Computing 2013)</span>. Irrespective of the
applicability of the CRF 11 to <strong>adoptr</strong>, the design of a
clinical trial is undoubtedly crucial and package authors should provide
extensive evidence of the correctness of the package functionality.
Additionally, this evidence should be easily accessible and
human-readable. The latter requirement is a consequence of the fact
that, again following CRF 11 and the remarks in <span class="citation">The R Foundation for Statistical Computing
(2013)</span>, a ‘validated <strong>R</strong>-package’ does not exist
since the validation process must always be implemented by the
responsible user.</p>
<p>To facilitate the process of validation as much as possible,
<strong>adoptr</strong> implements the following measures:</p>
<ol style="list-style-type: decimal">
<li>
<em>Open-source development:</em> The entire development of
<strong>adoptr</strong> is organized around a public GitHub.com
repository (<a href="https://github.com/optad/adoptr" class="external-link uri">https://github.com/optad/adoptr</a>). Anybody can freely
download the source code, browse the development history, raise issues,
or contribute to the code base by opening pull requests.</li>
<li>
<em>CRAN releases:</em> Regular CRAN <span class="citation">(CRAN
2020)</span> releases of updated versions maximize visibility and add an
additional layer of testing and quality control. New features can be
implemented and tested in the (public) development version on GitHub
before pushing new releases to CRAN.</li>
<li>
<em>Unit testing:</em> <strong>adoptr</strong> implements an
extensive test suite using the package <strong>testthat</strong> (<span class="citation">H. Wickham, R Studio, and R Core Team (2018)</span>,
<span class="citation">H. Wickham (2011)</span>) which allows spotting
new errors early during development and localizing them quickly.
Together with continuous integration (cf. below), this helps to improve
quality and speeds up the development process.</li>
<li>
<em>Continuous Integration / Continuous Deployment:</em>
<strong>adoptr</strong> makes extensive use of the continuous
integration and deployment services GitHub Actions <span class="citation">(GitHub.com 2021)</span>. Each new commit on the public
GitHub.com repository is immediately run through the automated testing
pipeline. Merges to the main branch are only possible after tests were
passed successfully and a contributor reviewed and approved the changes
(‘branch protection system’). Continuous deployment allows automatically
updating code-coverage statistics (cf. below) and up-to-date online
documentation (cf. below).</li>
<li>
<em>Coverage analyses:</em> To document the extent to which the test
suite covers the package code, <strong>adoptr</strong> relies on the
codecov <span class="citation">(Codecov LLC 2020)</span> online service
in conjunction with the <strong>covr</strong> package <span class="citation">(Hester 2019)</span>. It provides statistics on the
proportion of lines visited at least once during testing (currently
100%) and enables easy online publication of the results.</li>
<li>
<em>Online documentation:</em> Beyond the standard documentation
generated using <strong>roxygen2</strong> <span class="citation">(Hadley
Wickham et al. 2019)</span>, we also make use of the
<strong>pkgdown</strong> <span class="citation">(H. Wickham and
Hesselberth 2019)</span> package and the free GitHub pages service to
publish a static <strong>html</strong> version of the documentation
online at <a href="https://optad.github.io/adoptr/" class="uri">https://optad.github.io/adoptr/</a>. This includes both the
function reference and the vignettes in a consistent and easily
accessible format. The online documentation experience is further
improved by the integration of a full-text docsearch engine (<a href="https://www.algolia.com/ref/docsearch" class="external-link uri">https://www.algolia.com/ref/docsearch</a>).</li>
<li>
<em>Extended validation report:</em> There are limits to what can be
done in the standard unit testing framework within a package itself
(cf. <a href="https://cran.r-project.org/web/packages/policies.html" class="external-link uri">https://cran.r-project.org/web/packages/policies.html</a>).
Long-running test suites also hinder active development with a strict
continuous integration and continuous deployment (CI/CD) workflow since
changes to the main branch require passing the automated tests. We,
therefore, decided to restrict the internal unit tests to a bare minimum
with a clear focus on coverage and technical integrity of the package.
To demonstrate correctness of our results over a larger set of examples
and in comparison with existing packages such as <strong>rpact</strong>,
we implemented an external ‘validation report’ (sources: <a href="https://github.com/optad/adoptr-validation-report" class="external-link uri">https://github.com/optad/adoptr-validation-report</a>,
current report: <a href="https://optad.github.io/adoptr-validation-report/" class="uri">https://optad.github.io/adoptr-validation-report/</a>) using
the <strong>bookdown</strong> (<span class="citation">Xie (2019)</span>,
<span class="citation">Xie (2016)</span>) package. The report itself
again uses CI/CD and daily rebuilds to automatically deploy the report
corresponding to the most current CRAN-hosted version of the package.
Within the report, we still use <strong>testthat</strong> to conduct
formal tests. In case any of these tests fails, the build of the report
will fail, the maintainers will get notified, and the status indicator
in the repository changes.</li>
</ol>
<p>Validating the software employed may well be as much work as
developing it in the first place. The opaque requirements and the lack
of adequate tools to automate validation tasks are a major hurdle for
academic developers to address validation issues. The additional work,
however, is worth it since it not only improves quality but also
facilitates collaboration and makes it easier to promote packages for
real-world use.</p>
</div>
<div class="section level2">
<h2 id="future-work">Future work<a class="anchor" aria-label="anchor" href="#future-work"></a>
</h2>
<p>The main motivation of implementing <strong>adoptr</strong> in
<strong>R</strong> is the fact that this is by far the most common
programming language used by the target audience. Note, however, that
using <strong>R</strong> for generic nonlinear constraint optimization
problems leads to a performance bottleneck since there is currently no
stable and efficient way of obtaining gradient information for generic,
user-defined functions. Since one of the design principles of
<strong>adoptr</strong> is extensibility, the ability to support custom
objective functions is central. In <strong>R</strong>, this implies that
one has to resort to either a finite differences approximation of first-
and second-order derivatives or to a completely gradient-free optimizer
such as COBYLA. In our experiments, we found that COBYLA was far more
stable than a finite-differences augmented Lagrangian method (data not
shown). Still, for some problems, convergence using COBYLA is rather
slow. An interesting alternative to <strong>R</strong> and
<strong>nloptr</strong> would therefore be <strong>Julia</strong> <span class="citation">(Bezanson et al. 2017)</span> and the
<strong>JuMP</strong> framework for numerical programming <span class="citation">(Lubin and Dunning 2015)</span>. This framework allows
interfacing generic nonlinear solvers via a common interface and,
leveraging <strong>Julia</strong>’s excellent automatic-differentiation
capabilities, is able to provide fast and precise (second-order)
gradient information for user-defined objective functions.</p>
</div>
<div class="section level2">
<h2 id="acknowledgments">Acknowledgments<a class="anchor" aria-label="anchor" href="#acknowledgments"></a>
</h2>
<p>The first two authors contributed equally to this manuscript.</p>
<p>This work was partly supported by the Deutsche Forschungsgemeinschaft
under Grant number KI 708/4-1.</p>
</div>
<div class="section level2">
<h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-Bauer2015" class="csl-entry">
Bauer, P., F. Bretz, V. Dragalin, F. König, and G. Wassmer. 2015.
<span>“Twenty-Five Years of Confirmatory Adaptive Designs: Opportunities
and Pitfalls.”</span> <em>Statistics in Medicine</em> 35 (3): 325–47. <a href="https://doi.org/10.1002/sim.6472" class="external-link">https://doi.org/10.1002/sim.6472</a>.
</div>
<div id="ref-BK1994" class="csl-entry">
Bauer, P., and K. Köhne. 1994. <span>“Evaluation of Experiments with
Adaptive Interim Analyses.”</span> <em>Biometrics</em> 50 (4): 1029–41.
</div>
<div id="ref-Julia" class="csl-entry">
Bezanson, J., A. Edelman, S. Karpinski, and V. Shah. 2017. <span>“Julia:
A Fresh Approach to Numerical Computing.”</span> <em>SIAM Review</em> 59
(1): 65–98. <a href="https://doi.org/10.1137/141000671" class="external-link">https://doi.org/10.1137/141000671</a>.
</div>
<div id="ref-codecov" class="csl-entry">
Codecov LLC. 2020. <em>Codecov</em>. <a href="https://about.codecov.io/" class="external-link">https://about.codecov.io/</a>.
</div>
<div id="ref-EMA" class="csl-entry">
Committee for Medicinal Products for Human Use and others. 2007.
<span>“Reflection Paper on Methodological Issues in Confirmatory
Clinical Trials Planned with an Adaptive Design.”</span> <em>London:
EMEA</em>. <a href="https://www.ema.europa.eu/en/methodological-issues-confirmatory-clinical-trials-planned-adaptive-design-scientific-guideline" class="external-link">https://www.ema.europa.eu/en/methodological-issues-confirmatory-clinical-trials-planned-adaptive-design-scientific-guideline</a>.
</div>
<div id="ref-cran" class="csl-entry">
CRAN. 2020. <em>Comprehensive r Archive Network</em>. <a href="https://cran.r-project.org/" class="external-link">https://cran.r-project.org/</a>.
</div>
<div id="ref-east2020" class="csl-entry">
Cytel. 2020. <em>East<sup></sup> 6</em>. <a href="https://www.cytel.com/software/east/" class="external-link">https://www.cytel.com/software/east/</a>.
</div>
<div id="ref-Englert2013" class="csl-entry">
Englert, S., and M. Kieser. 2013. <span>“Optimal Adaptive Two-Stage
Designs for Phase II Cancer Clinical Trials.”</span> <em>Biometrical
Journal</em> 55: 955–68. <a href="https://doi.org/10.1002/bimj.201200220" class="external-link">https://doi.org/10.1002/bimj.201200220</a>.
</div>
<div id="ref-Spline" class="csl-entry">
Fritsch, F. N., and R. E. Carlson. 1980. <span>“Monotone Piecewise Cubic
Interpolation.”</span> <em>SIAM Journal on Numerical Analysis</em> 17
(2): 238–46. <a href="https://doi.org/10.1137/0717021" class="external-link">https://doi.org/10.1137/0717021</a>.
</div>
<div id="ref-ghactions" class="csl-entry">
GitHub.com. 2021. <em><span>GitHub Actions</span></em>. <a href="https://docs.github.com/en/actions/" class="external-link">https://docs.github.com/en/actions/</a>.
</div>
<div id="ref-AGSDest" class="csl-entry">
Hack, N., W. Brannath, and M. Brueckner. 2019. <em>AGSDest: Estimation
in Adaptive Group Sequential Trials</em>. <a href="https://CRAN.R-project.org/package=AGSDest" class="external-link">https://CRAN.R-project.org/package=AGSDest</a>.
</div>
<div id="ref-HO1985" class="csl-entry">
Hedges, L., and I. Olkin. 1985. <em>Statistical Methods in
Meta-Analysis</em>. Academic Press.
</div>
<div id="ref-covr" class="csl-entry">
Hester, Jim. 2019. <em>Covr: Test Coverage for Packages</em>. <a href="https://CRAN.R-project.org/package=covr" class="external-link">https://CRAN.R-project.org/package=covr</a>.
</div>
<div id="ref-addplan2020" class="csl-entry">
ICON plc. 2020. <em>ADDPLAN<sup></sup></em>.
</div>
<div id="ref-JT2015" class="csl-entry">
Jennison, C., and B. W. Turnbull. 2015. <span>“Adaptive Sample Size
Modification in Clinical Trials: Start Small Then Ask for More?”</span>
<em>Statistics in Medicine</em> 34 (29): 3793–3810. <a href="https://doi.org/10.1002/sim.6575" class="external-link">https://doi.org/10.1002/sim.6575</a>.
</div>
<div id="ref-nlopt" class="csl-entry">
Johnson, S. G. 2018. <em>The NLopt Nonlinear-Optimization Package</em>.
<a href="https://nlopt.readthedocs.io/en/latest/" class="external-link">https://nlopt.readthedocs.io/en/latest/</a>.
</div>
<div id="ref-Kunzmann2016" class="csl-entry">
Kunzmann, K., and M. Kieser. 2016. <span>“Optimal Adaptive Two-Stage
Designs for Single-Arm Trial with Binary Endpoint.”</span>
<em>arXiv</em>, 1605.00249.
</div>
<div id="ref-Kunzmann2019" class="csl-entry">
———. 2020. <span>“Optimal Adaptive Single-Arm Phase II Trials Under
Quantified Uncertainty.”</span> <em>Journal of Biopharmaceutical
Statistics</em> 30 (1): 89–103. <a href="https://doi.org/10.1080/10543406.2019.1609016" class="external-link">https://doi.org/10.1080/10543406.2019.1609016</a>.
</div>
<div id="ref-new-scores" class="csl-entry">
Kunzmann, K., and M. Pilz. 2020. <em>Defining New Scores</em>. <a href="https://rdrr.io/cran/adoptr/f/vignettes/defining-new-scores.Rmd" class="external-link">https://rdrr.io/cran/adoptr/f/vignettes/defining-new-scores.Rmd</a>.
</div>
<div id="ref-LW1999" class="csl-entry">
Lehmacher, W., and G. Wassmer. 1999. <span>“Adaptive Sample Size
Calculations in Group Sequential Trials.”</span> <em>Biometrics</em> 55
(4): 1286–90. <a href="https://doi.org/10.1111/j.0006-341X.1999.01286.x" class="external-link">https://doi.org/10.1111/j.0006-341X.1999.01286.x</a>.
</div>
<div id="ref-JuMP" class="csl-entry">
Lubin, M., and I. Dunning. 2015. <span>“Computing in Operations Research
Using Julia.”</span> <em>INFORMS Journal on Computing</em> 27 (2):
238–48. <a href="https://doi.org/10.1287/ijoc.2014.0623" class="external-link">https://doi.org/10.1287/ijoc.2014.0623</a>.
</div>
<div id="ref-MP2011" class="csl-entry">
Mehta, C. R., and S. J. Pocock. 2011. <span>“Adaptive Increase in Sample
Size When Interim Results Are Promising: A Practical Guide with
Examples.”</span> <em>Statistics in Medicine</em> 30 (28): 3267–84. <a href="https://doi.org/10.1002/sim.4102" class="external-link">https://doi.org/10.1002/sim.4102</a>.
</div>
<div id="ref-minitab2020" class="csl-entry">
Minitab, Inc. 2020. <em>Minitab 19 Statistical Software
<sup></sup></em>. <a href="https://www.minitab.com" class="external-link">https://www.minitab.com</a>.
</div>
<div id="ref-pass2019" class="csl-entry">
NCSS. 2019. <em>PASS Sample Size 2019 <sup></sup></em>. <a href="https://www.ncss.com/software/pass/" class="external-link">https://www.ncss.com/software/pass/</a>.
</div>
<div id="ref-OBF" class="csl-entry">
O’Brien, P. C., and T. R. Fleming. 1979. <span>“A Multiple Testing
Procedure for Clinical Trials.”</span> <em>Biometrics</em> 35 (3):
549–56.
</div>
<div id="ref-variational" class="csl-entry">
Pilz, M., K. Kunzmann, C. Herrmann, G. Rauch, and M. Kieser. 2019.
<span>“A Variational Approach to Optimal Two-Stage Designs.”</span>
<em>Statistics in Medicine</em> 38 (21): 4159–71. <a href="https://doi.org/10.1002/sim.8291" class="external-link">https://doi.org/10.1002/sim.8291</a>.
</div>
<div id="ref-Pocock" class="csl-entry">
Pocock, S. J. 1977. <span>“Group Sequential Methods in the Design and
Analysis of Clinical Trials.”</span> <em>Biometrika</em> 64 (2): 191–99.
<a href="https://doi.org/10.1093/biomet/64.2.191" class="external-link">https://doi.org/10.1093/biomet/64.2.191</a>.
</div>
<div id="ref-COBYLA" class="csl-entry">
Powell, M. J. D. 1994. <span>“A Direct Search Optimization Method That
Models the Objective and Constraint Functions by Linear
Interpolation.”</span> In <em>Advances in Optimization and Numerical
Analysis</em>, 51–67. Dordrecht: Springer-Verlag Netherlands. <a href="https://doi.org/10.1007/978-94-015-8330-5_4" class="external-link">https://doi.org/10.1007/978-94-015-8330-5_4</a>.
</div>
<div id="ref-R" class="csl-entry">
R Core Team. 2019. <em>R: A Language and Environment for Statistical
Computing</em>. Vienna, Austria: The R Foundation for Statistical
Computing. <a href="https://www.R-project.org/" class="external-link">https://www.R-project.org/</a>.
</div>
<div id="ref-jmp2020" class="csl-entry">
SAS Institute Inc., NC, Cary. n.d.a. <em>JMP Clinical <sup></sup></em>.
</div>
<div id="ref-sas2020" class="csl-entry">
———. n.d.b. <em>SAS<sup></sup></em>.
</div>
<div id="ref-r-fda" class="csl-entry">
The R Foundation for Statistical Computing. 2013. <span>“R: Regulatory
Compliance and Validation Issues - a Guidance Document for the Use of r
in Regulated Clinical Trial Environments.”</span> <a href="https://www.r-project.org/doc/R-FDA.pdf" class="external-link">https://www.r-project.org/doc/R-FDA.pdf</a>.
</div>
<div id="ref-Tymofyeyev2014" class="csl-entry">
Tymofyeyev, Y. 2014. <span>“A Review of Available Software and
Capabilities for Adaptive Designs.”</span> In <em>Practical
Considerations for Adaptive Trial Design and Implementation</em>,
139–55. Springer-Verlag New York. <a href="https://doi.org/10.1007/978-1-4939-1100-4_8" class="external-link">https://doi.org/10.1007/978-1-4939-1100-4_8</a>.
</div>
<div id="ref-FDA" class="csl-entry">
US Food and Drug Administration et al. 2019. <em>Adaptive Designs for
Clinical Trials of Drugs and Biologics - Guidance for Industry</em>. <a href="https://www.fda.gov/media/78495/download" class="external-link">https://www.fda.gov/media/78495/download</a>.
</div>
<div id="ref-crf11" class="csl-entry">
US Food and Drug Administration and others. 2003. <span>“Guidance for
Industry Part 11, Electronic Records; Electronic Signatures — Scope and
Application.”</span> <em>US Food Drug Admin, Rockville</em>. <a href="https://www.fda.gov/media/75414/download" class="external-link">https://www.fda.gov/media/75414/download</a>.
</div>
<div id="ref-adaptTest" class="csl-entry">
Vandemeulebroecke, M. 2009. <em>adaptTest: Adaptive Two-Stage
Tests</em>. <a href="https://CRAN.R-project.org/package=adaptTest" class="external-link">https://CRAN.R-project.org/package=adaptTest</a>.
</div>
<div id="ref-OptGS_pub" class="csl-entry">
Wason, J. M. S. 2015. <span>“OptGS: An r Package for Finding
Near-Optimal Group-Sequential Designs.”</span> <em>Journal of
Statistical Software</em> 66 (2): 1–13. <a href="https://doi.org/10.18637/jss.v066.i02" class="external-link">https://doi.org/10.18637/jss.v066.i02</a>.
</div>
<div id="ref-OptGS" class="csl-entry">
Wason, J. M. S., and J. Burkardt. 2015. <em>OptGS: Near-Optimal and
Balanced Group-Sequential Designs for Clinical Trials with Continuous
Outcomes</em>. <a href="https://CRAN.R-project.org/package=OptGS" class="external-link">https://CRAN.R-project.org/package=OptGS</a>.
</div>
<div id="ref-Wassmer2016" class="csl-entry">
Wassmer, G., and W. Brannath. 2016. <em>Group Sequential and
Confirmatory Adaptive Designs in Clinical Trials</em>. Springer Series
in Pharmaceutical Statistics -. Springer International Publishing. <a href="https://doi.org/10.1007/978-3-319-32562-0" class="external-link">https://doi.org/10.1007/978-3-319-32562-0</a>.
</div>
<div id="ref-rpact" class="csl-entry">
Wassmer, G., and F. Pahlke. 2019. <em>Rpact: Confirmatory Adaptive
Clinical Trial Design and Analysis</em>. <a href="https://CRAN.R-project.org/package=rpact" class="external-link">https://CRAN.R-project.org/package=rpact</a>.
</div>
<div id="ref-testthat_pub" class="csl-entry">
Wickham, H. 2011. <span>“Testthat: Get Started with Testing.”</span>
<em>The R Journal</em> 3: 5–10. <a href="https://doi.org/10.32614/RJ-2011-002" class="external-link">https://doi.org/10.32614/RJ-2011-002</a>.
</div>
<div id="ref-roxygen" class="csl-entry">
Wickham, Hadley, Peter Danenberg, Gábor Csárdi, and Manuel Eugster.
2019. <em>Roxygen2: In-Line Documentation for r</em>. <a href="https://CRAN.R-project.org/package=roxygen2" class="external-link">https://CRAN.R-project.org/package=roxygen2</a>.
</div>
<div id="ref-pkgdown" class="csl-entry">
Wickham, H., and J. Hesselberth. 2019. <em>Pkgdown: Make Static HTML
Documentation for a Package</em>. <a href="https://CRAN.R-project.org/package=pkgdown" class="external-link">https://CRAN.R-project.org/package=pkgdown</a>.
</div>
<div id="ref-testthat" class="csl-entry">
Wickham, H., R Studio, and R Core Team. 2018. <em>Testthat: Unit Testing
for r</em>. <a href="https://CRAN.R-project.org/package=testthat" class="external-link">https://CRAN.R-project.org/package=testthat</a>.
</div>
<div id="ref-bookdown_pub" class="csl-entry">
Xie, Y. 2016. <em>Bookdown: Authoring Books and Technical Documents with
r Markdown</em>. Boca Raton, Florida: Chapman; Hall/CRC. <a href="https://doi.org/10.1201/9781315204963" class="external-link">https://doi.org/10.1201/9781315204963</a>.
</div>
<div id="ref-bookdown" class="csl-entry">
———. 2019. <em>Bookdown: Authoring Books and Technical Documents with r
Markdown</em>. <a href="https://github.com/rstudio/bookdown" class="external-link">https://github.com/rstudio/bookdown</a>.
</div>
<div id="ref-nloptr" class="csl-entry">
Ypma, J., H. W. Borchers, and D. Eddelbuettel. 2018. <em>Nloptr: R
Interface to NLopt</em>. <a href="https://CRAN.R-project.org/package=nloptr" class="external-link">https://CRAN.R-project.org/package=nloptr</a>.
</div>
<div id="ref-Zaykin2011" class="csl-entry">
Zaykin, D. V. 2011. <span>“Optimally Weighted z-Test Is a Powerful
Method for Combining Probabilities in Meta-Analysis.”</span> <em>Journal
of Evolutionary Biology</em> 24 (8): 1836–41. <a href="https://doi.org/10.1111/j.1420-9101.2011.02297.x" class="external-link">https://doi.org/10.1111/j.1420-9101.2011.02297.x</a>.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Kevin Kunzmann, Maximilian Pilz, Jan Meis, Nico Bruder.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
